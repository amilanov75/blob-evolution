<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blob Evolution (Standalone)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
        }
        
        #gameCanvas {
            background: #fff;
            width: 480px;
            height: 720px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <script>
        // Canvas class
        class Canvas {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.setCanvasSize();
                window.addEventListener('resize', () => this.setCanvasSize());
            }

            setCanvasSize() {
                this.canvas.width = 480;
                this.canvas.height = 720;
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
        }

        // Biome class
        class Biome {
            constructor(type, color, temperatureEffect, resources) {
                this.type = type;
                this.color = color;
                this.temperatureEffect = temperatureEffect; // Effect on blob temperature in Celsius
                this.resources = resources; // Resources available in this biome
            }
        }

        // Inventory Item class
        class InventoryItem {
            constructor(type, name, description, rarity = 'common', drawIcon = null) {
                this.type = type;
                this.name = name;
                this.description = description;
                this.quantity = 1;
                this.rarity = rarity;
                this.drawIcon = drawIcon || ((ctx, x, y, size) => {
                    // Default icon if no custom drawing function provided
                    console.log('Using default icon for:', name);
                    ctx.fillStyle = this.getIconColor();
                    ctx.fillRect(x + 5, y + 5, size - 10, size - 10);
                });
                console.log('Created InventoryItem:', name, 'Has custom drawIcon?', !!drawIcon);
            }
            
            getIconColor() {
                switch(this.rarity) {
                    case 'common': return '#AAAAAA';
                    case 'uncommon': return '#55AA55';
                    case 'rare': return '#5555FF';
                    case 'epic': return '#AA55AA';
                    case 'legendary': return '#FFAA00';
                    default: return '#FFFFFF';
                }
            }
        }

        // Inventory class to manage the blob's items
        class Inventory {
            constructor() {
                this.items = {};
                this.selectedItem = null;
                this.visible = true;
                this.maxSlots = 12;
                console.log('Inventory created');
            }
            
            toggleVisibility() {
                // No longer needed, but kept for compatibility
                this.visible = true;
            }
            
            addItem(item) {
                console.log('Adding item:', item);
                console.log('Item has drawIcon?', !!item.drawIcon);
                
                if (this.items[item.name]) {
                    this.items[item.name].quantity += (item.quantity || 1);
                    console.log(`Increased quantity of ${item.name} to ${this.items[item.name].quantity}`);
                    return true;
                } else if (Object.keys(this.items).length < this.maxSlots) {
                    if (!item.hasOwnProperty('quantity')) {
                        item.quantity = 1;
                    }
                    this.items[item.name] = item;
                    console.log(`Added new item ${item.name} to inventory`, item);
                    return true;
                }
                console.log('Inventory full, cannot add item:', item.name);
                return false;
            }
            
            removeItem(itemName, quantity) {
                if (quantity === undefined) quantity = 1;
                
                console.log(`Attempting to remove ${quantity} of ${itemName} from inventory`);
                
                if (!itemName) {
                    console.error('Invalid item name provided to removeItem');
                    return false;
                }
                
                if (!this.items[itemName]) {
                    console.error(`Item "${itemName}" not found in inventory`);
                    return false;
                }
                
                if (this.items[itemName].quantity < quantity) {
                    console.error(`Not enough ${itemName} in inventory. Have ${this.items[itemName].quantity}, need ${quantity}`);
                    return false;
                }
                
                // All checks passed, now remove the item
                this.items[itemName].quantity -= quantity;
                console.log(`Removed ${quantity} ${itemName}, new quantity: ${this.items[itemName].quantity}`);
                
                // If quantity is now zero, remove the item from inventory
                if (this.items[itemName].quantity <= 0) {
                    console.log(`${itemName} quantity is now 0, removing from inventory`);
                    delete this.items[itemName];
                    
                    // If this was the selected item, deselect it
                    if (this.selectedItem === itemName) {
                        console.log(`Deselecting ${itemName} as it was removed from inventory`);
                        this.selectedItem = null;
                    }
                }
                
                return true;
            }
            
            // Get all building materials
            getBuildingMaterials() {
                var materials = {};
                for (var name in this.items) {
                    var item = this.items[name];
                    if (item.type === 'resource') {
                        materials[name] = item.quantity;
                    }
                }
                return materials;
            }
            
            // Method to upgrade inventory capacity (increases when blob evolves)
            upgradeCapacity(amount) {
                this.maxSlots += amount;
            }
            
            draw(ctx, canvasWidth, canvasHeight) {
                const itemSize = 40;
                const padding = 10;
                const bottomPadding = 20;
                const itemsPerRow = 3; // Changed from 6 to 3 for mobile format
                
                // Make sure all items have proper quantity values
                for (const name in this.items) {
                    if (this.items[name] && typeof this.items[name].quantity !== 'number') {
                        this.items[name].quantity = 1;
                    }
                }
                
                let itemIndex = 0;
                for (const name in this.items) {
                    const item = this.items[name];
                    
                    // Skip invalid items
                    if (!item) continue;
                    
                    const row = Math.floor(itemIndex / itemsPerRow);
                    const col = itemIndex % itemsPerRow;
                    
                    // Use the same position calculation as in handleClick
                    const x = padding + col * (itemSize + padding);
                    const y = canvasHeight - bottomPadding - (itemSize + padding) * (row + 1);
                    
                    // Draw item background with gradient
                    const gradient = ctx.createLinearGradient(x, y, x, y + itemSize);
                    gradient.addColorStop(0, 'rgba(0, 0, 0, 0.7)');
                    gradient.addColorStop(1, 'rgba(20, 20, 20, 0.7)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, y, itemSize, itemSize);
                    
                    // Draw item icon using the custom drawing function
                    if (item.drawIcon) {
                        try {
                            item.drawIcon(ctx, x, y, itemSize);
                        } catch (error) {
                            console.error('Error drawing icon for', name, error);
                            // Fallback to default drawing
                            ctx.fillStyle = '#FF0000';
                            ctx.fillRect(x + 5, y + 5, itemSize - 10, itemSize - 10);
                        }
                    } else {
                        ctx.fillStyle = '#FF0000';
                        ctx.fillRect(x + 5, y + 5, itemSize - 10, itemSize - 10);
                    }
                    
                    // Draw border (highlighted if selected)
                    ctx.lineWidth = this.selectedItem === name ? 3 : 1;
                    ctx.strokeStyle = this.selectedItem === name ? '#FFFF00' : '#888888';
                    ctx.strokeRect(x, y, itemSize, itemSize);
                    
                    // Draw quantity with background
                    const quantityBg = ctx.createLinearGradient(x, y + itemSize - 15, x + 20, y + itemSize);
                    quantityBg.addColorStop(0, 'rgba(0, 0, 0, 0.8)');
                    quantityBg.addColorStop(1, 'rgba(20, 20, 20, 0.8)');
                    ctx.fillStyle = quantityBg;
                    ctx.fillRect(x, y + itemSize - 15, 20, 15);
                    
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(item.quantity, x + 4, y + itemSize - 3);
                    
                    // Draw item name on hover or if selected
                    if (this.selectedItem === name) {
                        // Draw item details BELOW the item instead of above
                        const detailsY = y + itemSize + 10;
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillRect(x, detailsY, 150, 50);
                        
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = '14px Arial';
                        ctx.fillText(item.name.charAt(0).toUpperCase() + item.name.slice(1) + ' (' + item.rarity + ')', x + 5, detailsY + 20);
                        ctx.font = '12px Arial';
                        ctx.fillText(item.description, x + 5, detailsY + 40);
                    }
                    
                    itemIndex++;
                }
            }
            
            // Method to handle click on inventory
            handleClick(x, y, canvasWidth, canvasHeight) {
                const itemSize = 40;
                const padding = 10;
                const bottomPadding = 20;
                const itemsPerRow = 3; // Changed from 6 to 3 for mobile format
                
                let itemIndex = 0;
                let previousSelectedItem = this.selectedItem;
                
                for (const name in this.items) {
                    const row = Math.floor(itemIndex / itemsPerRow);
                    const col = itemIndex % itemsPerRow;
                    
                    const itemX = padding + col * (itemSize + padding);
                    const itemY = canvasHeight - bottomPadding - (itemSize + padding) * (row + 1);
                    
                    // Check if click is within this item's bounds
                    if (x >= itemX && x <= itemX + itemSize && 
                        y >= itemY && y <= itemY + itemSize) {
                        // Toggle selection
                        this.selectedItem = this.selectedItem === name ? null : name;
                        console.log('Selected item:', this.selectedItem);
                        
                        // Trigger a custom event to update activeFood in the Person class
                        const event = new CustomEvent('inventorySelectionChanged', {
                            detail: {
                                selectedItem: this.selectedItem,
                                previousSelectedItem: previousSelectedItem
                            }
                        });
                        window.dispatchEvent(event);
                        return;
                    }
                    
                    itemIndex++;
                }
                
                // If click wasn't on any item, deselect
                this.selectedItem = null;
                const event = new CustomEvent('inventorySelectionChanged', {
                    detail: {
                        selectedItem: null,
                        previousSelectedItem: previousSelectedItem
                    }
                });
                window.dispatchEvent(event);
            }
        }

        // Food class
        class Food {
            constructor(x, y, type, nutrientValue, energyValue) {
                this.x = x;
                this.y = y;
                this.type = type; // e.g., 'berries', 'fish', 'kibble', 'steak', etc.
                this.radius = 9; // Reduced from 10 to 9 to match smaller biomes
                this.nutrientValue = nutrientValue; // How much hunger it restores
                this.energyValue = energyValue; // How much energy it provides
                this.color = this.getFoodColor(type);
                this.collected = false;
                this.inventoryItem = this.getInventoryItem(); // What item this adds to inventory
            }
            
            getFoodColor(type) {
                // Different colors for different food types
                switch(type) {
                    case 'berries': return '#CC0066'; // Dark red/magenta for berries
                    case 'nuts': return '#8B4513'; // Brown for nuts
                    case 'cactus': return '#7FFF00'; // Chartreuse for cactus
                    case 'fish': return '#4682B4'; // Steel blue for fish
                    case 'minerals': return '#B8B8B8'; // Light grey for minerals
                    case 'kibble': return '#FFA500'; // Orange for kibble
                    case 'steak': return '#8B0000'; // Dark red for steak
                    case 'cake': return '#FFFF00'; // Yellow for cake
                    case 'vegetables': return '#228B22'; // Forest green for vegetables
                    default: return '#FFFF00'; // Yellow default
                }
            }
            
            getInventoryItem() {
                const type = this.type;
                console.log('Creating inventory item for food type:', type);
                
                // Define drawing functions outside of the switch to ensure proper binding
                const drawBerries = (ctx, x, y, size) => {
                    console.log('Drawing berries');
                    // Draw berry cluster
                    ctx.fillStyle = '#CC0066';
                    ctx.beginPath();
                    ctx.arc(x + size * 0.3, y + size * 0.3, size * 0.2, 0, Math.PI * 2);
                    ctx.arc(x + size * 0.7, y + size * 0.4, size * 0.2, 0, Math.PI * 2);
                    ctx.arc(x + size * 0.5, y + size * 0.7, size * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    // Add leaves
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.ellipse(x + size * 0.2, y + size * 0.2, size * 0.15, size * 0.1, Math.PI/4, 0, Math.PI * 2);
                    ctx.ellipse(x + size * 0.8, y + size * 0.3, size * 0.15, size * 0.1, -Math.PI/4, 0, Math.PI * 2);
                    ctx.fill();
                };

                const drawNuts = (ctx, x, y, size) => {
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.ellipse(x + size/2, y + size/2, size * 0.3, size * 0.4, Math.PI/4, 0, Math.PI * 2);
                    ctx.fill();
                    // Add texture lines
                    ctx.strokeStyle = '#5C2C0C';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + size * 0.3, y + size * 0.3);
                    ctx.lineTo(x + size * 0.7, y + size * 0.7);
                    ctx.moveTo(x + size * 0.3, y + size * 0.7);
                    ctx.lineTo(x + size * 0.7, y + size * 0.3);
                    ctx.stroke();
                };

                const drawCactus = (ctx, x, y, size) => {
                    ctx.fillStyle = '#7FFF00';
                    ctx.beginPath();
                    ctx.roundRect(x + size * 0.3, y + size * 0.2, size * 0.4, size * 0.6, 5);
                    ctx.fill();
                    // Add spikes
                    ctx.strokeStyle = '#666666';
                    ctx.lineWidth = 2;
                    for(let i = 0; i < 4; i++) {
                        ctx.beginPath();
                        ctx.moveTo(x + size * 0.3, y + size * (0.3 + i * 0.15));
                        ctx.lineTo(x + size * 0.15, y + size * (0.3 + i * 0.15));
                        ctx.moveTo(x + size * 0.7, y + size * (0.3 + i * 0.15));
                        ctx.lineTo(x + size * 0.85, y + size * (0.3 + i * 0.15));
                        ctx.stroke();
                    }
                };

                const drawFish = (ctx, x, y, size) => {
                    ctx.fillStyle = '#4682B4';
                    // Fish body
                    ctx.beginPath();
                    ctx.ellipse(x + size * 0.4, y + size/2, size * 0.3, size * 0.2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Tail
                    ctx.beginPath();
                    ctx.moveTo(x + size * 0.7, y + size * 0.3);
                    ctx.lineTo(x + size * 0.9, y + size/2);
                    ctx.lineTo(x + size * 0.7, y + size * 0.7);
                    ctx.closePath();
                    ctx.fill();
                    // Eye
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(x + size * 0.3, y + size * 0.45, size * 0.05, 0, Math.PI * 2);
                    ctx.fill();
                };

                const drawMinerals = (ctx, x, y, size) => {
                    ctx.fillStyle = '#B8B8B8';
                    // Crystal shape
                    ctx.beginPath();
                    ctx.moveTo(x + size/2, y + size * 0.2);
                    ctx.lineTo(x + size * 0.7, y + size * 0.4);
                    ctx.lineTo(x + size * 0.7, y + size * 0.6);
                    ctx.lineTo(x + size/2, y + size * 0.8);
                    ctx.lineTo(x + size * 0.3, y + size * 0.6);
                    ctx.lineTo(x + size * 0.3, y + size * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    // Highlight
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + size * 0.4, y + size * 0.3);
                    ctx.lineTo(x + size * 0.6, y + size * 0.3);
                    ctx.stroke();
                };

                // Store the drawing function for this food type to use in draw()
                this.drawFoodIcon = null;
                
                const item = (() => {
                    switch(type) {
                        case 'berries':
                            this.drawFoodIcon = drawBerries;
                            return new InventoryItem('resource', type, 'Sweet and nutritious', 'common', drawBerries);
                        case 'nuts':
                            this.drawFoodIcon = drawNuts;
                            return new InventoryItem('resource', type, 'Crunchy and filling', 'common', drawNuts);
                        case 'cactus':
                            this.drawFoodIcon = drawCactus;
                            return new InventoryItem('resource', type, 'Spiky but hydrating', 'common', drawCactus);
                        case 'fish':
                            this.drawFoodIcon = drawFish;
                            return new InventoryItem('resource', type, 'Fresh and healthy', 'uncommon', drawFish);
                        case 'minerals':
                            this.drawFoodIcon = drawMinerals;
                            return new InventoryItem('resource', type, 'Essential nutrients', 'common', drawMinerals);
                        default:
                            return null;
                    }
                })();
                
                if (item) {
                    console.log('Created food inventory item:', item.name, 'Has custom drawIcon?', !!item.drawIcon);
                }
                return item;
            }
            
            draw(ctx, cameraX, cameraY) {
                // Calculate screen position
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Only draw if on screen
                const buffer = this.radius * 3; // Buffer for larger icons
                if (screenX + buffer < 0 || screenX - buffer > ctx.canvas.width || 
                    screenY + buffer < 0 || screenY - buffer > ctx.canvas.height) {
                    return;
                }
                
                // Draw food item using the detailed icon if available
                if (this.drawFoodIcon) {
                    // Use moderate icon size that's still clearly visible
                    // Reduced from 3.4 to 3.0 for slightly smaller icons
                    const iconSize = this.radius * 3.0;
                    this.drawFoodIcon(ctx, screenX - iconSize/2, screenY - iconSize/2, iconSize);
                    
                    // Draw outline for better visibility
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.radius * 1.1, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    // Fallback to simple colored circle if no icon
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    
                    // Add a little shine/highlight
                    ctx.beginPath();
                    ctx.arc(screenX - this.radius/3, screenY - this.radius/3, this.radius/3, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.fill();
                }
            }
            
            // Check if the blob is collecting/eating this food
            isColliding(blob) {
                const dx = this.x - blob.x;
                const dy = this.y - blob.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < this.radius + blob.radius;
            }
        }

        // FoodManager class
        class FoodManager {
            constructor(worldWidth, worldHeight) {
                this.worldWidth = worldWidth;
                this.worldHeight = worldHeight;
                this.foods = [];
                this.maxFoods = 100; // Maximum number of food items at once (doubled from 50)
                this.spawnTimer = 0;
                this.spawnInterval = 500; // Time in ms between spawn attempts (halved from 1000)
                this.lastSpawnTime = Date.now();
            }
            
            update(biomeManager) {
                const now = Date.now();
                const deltaTime = now - this.lastSpawnTime;
                this.lastSpawnTime = now;
                
                // Increment spawn timer
                this.spawnTimer += deltaTime;
                
                // Attempt to spawn new food if timer exceeds interval
                if (this.spawnTimer >= this.spawnInterval) {
                    this.spawnTimer = 0;
                    // Try spawning multiple food items each update
                    for (let i = 0; i < 2; i++) {
                        this.trySpawnFood(biomeManager);
                    }
                }
            }
            
            trySpawnFood(biomeManager) {
                // Don't spawn if we're at the max
                if (this.foods.length >= this.maxFoods) return;
                
                // Random position in the world
                const x = Math.random() * this.worldWidth;
                const y = Math.random() * this.worldHeight;
                
                // Get the biome at this position
                const biome = biomeManager.getBiomeAt(x, y);
                
                // Only spawn if the biome has resources
                if (biome && biome.resources.length > 0) {
                    // Pick a random resource from this biome
                    const resourceType = biome.resources[Math.floor(Math.random() * biome.resources.length)];
                    
                    // Different food types have different values
                    let nutrientValue, energyValue;
                    
                    switch(resourceType) {
                        case 'berries':
                            nutrientValue = 15;
                            energyValue = 10;
                            break;
                        case 'nuts':
                            nutrientValue = 20;
                            energyValue = 15;
                            break;
                        case 'cactus':
                            nutrientValue = 10;
                            energyValue = 5;
                            break;
                        case 'fish':
                            nutrientValue = 25;
                            energyValue = 20;
                            break;
                        case 'minerals':
                            nutrientValue = 5;
                            energyValue = 30;
                            break;
                        default:
                            nutrientValue = 10;
                            energyValue = 10;
                    }
                    
                    // Create and add the food
                    const food = new Food(x, y, resourceType, nutrientValue, energyValue);
                    this.foods.push(food);
                }
            }
            
            draw(ctx, cameraX, cameraY) {
                // Draw all food items
                this.foods.forEach(food => {
                    if (!food.collected) {
                        food.draw(ctx, cameraX, cameraY);
                    }
                });
            }
            
            checkCollisions(blob) {
                // Skip if blob is dead
                if (blob.isDead) return;
                
                let foodEaten = false;
                
                for (let i = 0; i < this.foods.length; i++) {
                    const food = this.foods[i];
                    
                    // Skip if already collected
                    if (food.collected) continue;
                    
                    // Check if blob is eating this food (either by touch or collection mode)
                    const isColliding = food.isColliding(blob);
                    const isInCollectionRange = blob.collectionMode && this.isInCollectionRange(food, blob);
                    
                    if (isColliding || isInCollectionRange) {
                        foodEaten = true;
                        
                        // If this is from collection mode, show a visual hint
                        if (isInCollectionRange && !isColliding) {
                            // Draw a more dramatic animation for collection
                            const ctx = document.getElementById('gameCanvas').getContext('2d');
                            if (ctx) {
                                const screenX = blob.x - window.gameInstance.world.cameraX;
                                const screenY = blob.y - window.gameInstance.world.cameraY;
                                const foodScreenX = food.x - window.gameInstance.world.cameraX;
                                const foodScreenY = food.y - window.gameInstance.world.cameraY;
                                
                                // Draw animated line connecting blob to food
                                ctx.beginPath();
                                ctx.moveTo(screenX, screenY);
                                ctx.lineTo(foodScreenX, foodScreenY);
                                ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)'; // Brighter green
                                ctx.lineWidth = 4; // Thicker line
                                ctx.stroke();
                                
                                // Add particles effect moving from food to blob
                                const particleCount = 10;
                                for (let i = 0; i < particleCount; i++) {
                                    const t = i / particleCount;
                                    const particleX = foodScreenX + (screenX - foodScreenX) * t;
                                    const particleY = foodScreenY + (screenY - foodScreenY) * t;
                                    const size = 5 + Math.sin(Date.now() / 100 + i) * 3;
                                    
                                    ctx.beginPath();
                                    ctx.arc(particleX, particleY, size, 0, Math.PI * 2);
                                    ctx.fillStyle = `rgba(0, 255, ${Math.floor(i * 25)}, 0.8)`;
                                    ctx.fill();
                                }
                                
                                // Add glow around the food
                                ctx.beginPath();
                                ctx.arc(foodScreenX, foodScreenY, 15, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                                ctx.fill();
                            }
                        }
                        
                        // Apply the food effects to the blob
                        const hungerRestored = blob.stats.feed(food.nutrientValue, food.type);
                        blob.stats.rest(food.energyValue);
                        
                        // Some foods also heal the blob
                        if (food.type === 'fish' || food.type === 'berries') {
                            blob.stats.heal(5); // Fish and berries are healing
                        }
                        
                        // The blob eats the food and shouldn't store it in inventory
                        // Only the dog/person can store items in inventory
                        let inventoryMessage = "";
                        
                        // Mark as collected
                        food.collected = true;
                        
                        // Gain experience directly based on food's nutrient value
                        const didEvolve = blob.stats.gainExperienceFromFood(food.nutrientValue, food.type);
                        
                        // Show a small popup message with all effects
                        let message = `+${hungerRestored} hunger, +${food.energyValue} energy`;
                        if (food.type === 'fish' || food.type === 'berries') {
                            message += ', +5 health';
                        }
                        message += `, +${food.nutrientValue} XP`;
                        
                        // Add collection mode indicator if collected through collection mode
                        if (isInCollectionRange && !isColliding) {
                            message += " (Collection mode)";
                        }
                        
                        blob.showMessage(message);
                        
                        // Check evolution based on normal XP thresholds
                        if (didEvolve || blob.checkEvolution()) {
                            const evolutionDetails = blob.stats.getEvolutionDetails();
                            blob.evolve(evolutionDetails);
                        }
                    }
                }
                
                // Remove collected foods
                this.foods = this.foods.filter(food => !food.collected);
            }
            
            // Check if food is in the blob's collection range
            isInCollectionRange(food, blob) {
                const dx = food.x - blob.x;
                const dy = food.y - blob.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < blob.collectionRadius;
            }
        }

        // Biome Manager
        class BiomeManager {
            constructor(width, height, tileSize) {
                this.width = width;
                this.height = height;
                this.tileSize = 36; // Increased from 30 to 36 (20% larger)
                this.grid = [];
                this.biomeTypes = {
                    FOREST: new Biome('Forest', '#228B22', 0.5, ['berries', 'nuts']),     // Slight warming effect
                    DESERT: new Biome('Desert', '#F4A460', 3, ['cactus']),                // Stronger heating effect
                    WATER: new Biome('Water', '#1E90FF', -2, ['fish']),                   // Stronger cooling effect
                    MOUNTAINS: new Biome('Mountains', '#808080', -3, ['minerals'])         // Even stronger cooling effect
                };
                
                // Make the world much larger than the screen
                this.worldWidth = width * 5; // 5 times the canvas width
                this.worldHeight = height * 5; // 5 times the canvas height
                
                this.generateBiomes();
            }
            
            generateBiomes() {
                // Calculate grid dimensions for the larger world
                const gridWidth = Math.ceil(this.worldWidth / this.tileSize);
                const gridHeight = Math.ceil(this.worldHeight / this.tileSize);
                
                // Initialize grid with empty cells
                for (let y = 0; y < gridHeight; y++) {
                    const row = [];
                    for (let x = 0; x < gridWidth; x++) {
                        // Random biome assignment
                        const biomeKeys = Object.keys(this.biomeTypes);
                        const randomBiome = this.biomeTypes[biomeKeys[Math.floor(Math.random() * biomeKeys.length)]];
                        row.push(randomBiome);
                    }
                    this.grid.push(row);
                }
                
                // Smooth out biomes to create more natural-looking regions
                this.smoothBiomes(3);
            }
            
            smoothBiomes(iterations) {
                for (let i = 0; i < iterations; i++) {
                    const newGrid = JSON.parse(JSON.stringify(this.grid));
                    
                    for (let y = 0; y < this.grid.length; y++) {
                        for (let x = 0; x < this.grid[y].length; x++) {
                            const neighbors = this.getNeighbors(x, y);
                            if (neighbors.length > 0) {
                                // Find most common neighbor biome
                                const biomeCount = {};
                                let maxCount = 0;
                                let dominantBiome = this.grid[y][x];
                                
                                neighbors.forEach(neighbor => {
                                    const biomeType = neighbor.type;
                                    biomeCount[biomeType] = (biomeCount[biomeType] || 0) + 1;
                                    
                                    if (biomeCount[biomeType] > maxCount) {
                                        maxCount = biomeCount[biomeType];
                                        dominantBiome = neighbor;
                                    }
                                });
                                
                                // 50% chance to change to the dominant biome of neighbors
                                if (Math.random() < 0.5) {
                                    newGrid[y][x] = dominantBiome;
                                }
                            }
                        }
                    }
                    
                    this.grid = newGrid;
                }
            }
            
            getNeighbors(x, y) {
                const neighbors = [];
                const directions = [
                    [-1, -1], [0, -1], [1, -1],
                    [-1, 0],           [1, 0],
                    [-1, 1],  [0, 1],  [1, 1]
                ];
                
                directions.forEach(([dx, dy]) => {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < this.grid[0].length && ny >= 0 && ny < this.grid.length) {
                        neighbors.push(this.grid[ny][nx]);
                    }
                });
                
                return neighbors;
            }
            
            getBiomeAt(worldX, worldY) {
                const gridX = Math.floor(worldX / this.tileSize);
                const gridY = Math.floor(worldY / this.tileSize);
                
                // Check boundaries
                if (gridX >= 0 && gridX < this.grid[0].length && gridY >= 0 && gridY < this.grid.length) {
                    return this.grid[gridY][gridX];
                }
                
                // Default to forest if out of bounds
                return this.biomeTypes.FOREST;
            }
            
            draw(ctx, cameraX, cameraY, viewportWidth, viewportHeight) {
                // Calculate the visible grid cells based on camera position
                const startX = Math.floor(cameraX / this.tileSize);
                const startY = Math.floor(cameraY / this.tileSize);
                const endX = Math.ceil((cameraX + viewportWidth) / this.tileSize);
                const endY = Math.ceil((cameraY + viewportHeight) / this.tileSize);
                
                // Draw only visible biomes
                for (let y = startY; y < endY; y++) {
                    for (let x = startX; x < endX; x++) {
                        // Check if this grid position is within bounds
                        if (y >= 0 && y < this.grid.length && x >= 0 && x < this.grid[0].length) {
                            const biome = this.grid[y][x];
                            ctx.fillStyle = biome.color;
                            ctx.fillRect(
                                x * this.tileSize - cameraX, 
                                y * this.tileSize - cameraY, 
                                this.tileSize, 
                                this.tileSize
                            );
                        }
                    }
                }
                
                // Add grid lines for better visibility
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 1;
                
                // Only draw grid lines for the visible area
                // Vertical lines
                for (let x = startX; x <= endX; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * this.tileSize - cameraX, startY * this.tileSize - cameraY);
                    ctx.lineTo(x * this.tileSize - cameraX, endY * this.tileSize - cameraY);
                    ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = startY; y <= endY; y++) {
                    ctx.beginPath();
                    ctx.moveTo(startX * this.tileSize - cameraX, y * this.tileSize - cameraY);
                    ctx.lineTo(endX * this.tileSize - cameraX, y * this.tileSize - cameraY);
                    ctx.stroke();
                }
            }
            
            getWorldSize() {
                return {
                    width: this.worldWidth,
                    height: this.worldHeight
                };
            }
        }

        // Stats class
        class Stats {
            constructor() {
                // Initialize stats with default values (0-100 scale)
                this.hunger = 100;      // 100 = full, 0 = starving
                this.energy = 100;      // 100 = energetic, 0 = exhausted
                this.temperature = 20;  // In Celsius: 20°C = neutral
                this.mood = 75;         // 0 = sad, 100 = happy
                this.health = 100;      // 100 = perfect health, 0 = dead
                
                // Decay rates (amount lost per second)
                this.hungerDecayRate = 6.0;    // Increased from 5.5 - loses 6% hunger per second
                this.energyDecayRate = 2.2;    // Increased from 2.0 - loses 2.2% energy per second when not moving
                this.healthDecayRate = 0.45;   // Increased from 0.4 - loses 0.45% health per second when conditions are bad
                
                // Evolution stats
                this.experience = 0;    // Experience points earned
                this.evolutionLevel = 0; // Current evolution level
                // Generate more reasonable experience thresholds - average food gives ~15 XP
                // So 150 XP = ~10 food items
                this.experienceThresholds = [];
                this.experienceThresholds.push(150);  // Level 1: ~10 food items
                this.experienceThresholds.push(300);  // Level 2: ~10 more food items
                this.experienceThresholds.push(450);  // Level 3: ~10 more food items
                this.experienceThresholds.push(600);  // Level 4: ~10 more food items
                this.experienceThresholds.push(750);  // Level 5: ~10 more food items
                
                // For levels beyond 5, increase by 150 each time (10 more items per level)
                for (let i = 5; i < 100; i++) {
                    this.experienceThresholds.push(750 + (i - 4) * 150);
                }
                
                this.foodCounter = 0;   // Counter for food items eaten
                
                // Biome exposure tracking
                this.biomeExposure = {
                    Forest: 0,
                    Desert: 0, 
                    Water: 0,
                    Mountains: 0
                };
                
                // Food consumption tracking
                this.foodConsumed = {
                    berries: 0,
                    nuts: 0,
                    cactus: 0,
                    fish: 0,
                    minerals: 0
                };
                
                // Last update time for calculating delta time
                this.lastUpdate = Date.now();
                
                // Current biome the blob is in
                this.currentBiome = null;
                
                // Activity tracking
                this.isMoving = false;
            }
            
            update(currentBiome, isMoving) {
                const now = Date.now();
                const deltaTime = (now - this.lastUpdate) / 1000; // Convert to seconds
                this.lastUpdate = now;
                
                // Update current biome and movement state
                this.currentBiome = currentBiome;
                this.isMoving = isMoving;
                
                // Update hunger (always decreases over time)
                this.hunger = Math.max(0, this.hunger - this.hungerDecayRate * deltaTime);
                
                // Energy mechanics
                if (isMoving) {
                    // Energy decreases faster when moving
                    let movementEnergyCost = 3.8; // Increased from 3.5 - moving costs slightly more energy
                    
                    // Biome-specific energy costs can be adjusted by blob traits
                    this.energy = Math.max(0, this.energy - movementEnergyCost * deltaTime);
                } else {
                    // Energy regenerates when not moving, but only if hunger is above 60%
                    if (this.hunger > 60) {
                        // Reduced regeneration rate
                        this.energy = Math.min(100, this.energy + 0.1 * deltaTime * (this.hunger / 100));
                    } else {
                        // Energy decays faster when hunger is low, even when not moving
                        this.energy = Math.max(0, this.energy - this.energyDecayRate * 1.2 * deltaTime);
                    }
                }
                
                // Apply biome effects on temperature (in Celsius)
                if (currentBiome) {
                    // Increase effect of biome temperature changes (0.1 -> 0.3)
                    this.temperature += currentBiome.temperatureEffect * deltaTime * 0.3;
                    
                    // Natural temperature regulation - slowly return to neutral (20°C)
                    // Only applies when temperature effect is small, otherwise biome effect dominates
                    if (Math.abs(currentBiome.temperatureEffect) < 1) {
                        const tempDiff = 20 - this.temperature;
                        this.temperature += tempDiff * deltaTime * 0.1; // Slowly move toward 20°C
                    }
                    
                    // Keep temperature in reasonable range (-10°C to 45°C)
                    this.temperature = Math.max(-10, Math.min(45, this.temperature));
                    
                    // Track biome exposure time
                    this.biomeExposure[currentBiome.type] += deltaTime;
                    
                    // Gain experience in current biome
                    this.gainExperience(0.05 * deltaTime);
                }
                
                // If hunger is low, energy decreases faster and health begins to drop
                if (this.hunger < 45) { // Increased from 40 to 45 - even more challenging hunger threshold
                    this.energy = Math.max(0, this.energy - 2.5 * deltaTime); // Increased from 2.0 to 2.5 - even faster energy drain
                    
                    // Health decreases when hunger is critically low (starvation)
                    if (this.hunger < 25) { // Increased from 20 to 25
                        this.health = Math.max(0, this.health - 1.0 * deltaTime); // Increased from 0.8 to 1.0 for faster health loss
                    }
                }
                
                // If energy is low or completely depleted, health decreases (exhaustion)
                if (this.energy <= 20) { // Increased threshold from 15% to 20% energy
                    const healthLoss = this.energy <= 0 ? 1.5 : 0.7; // Increased from 1.0/0.5 to 1.5/0.7
                    this.health = Math.max(0, this.health - healthLoss * deltaTime);
                }
                
                // If temperature is extreme, energy decreases faster and health can drop
                if (this.temperature < 8 || this.temperature > 32) { // Narrower comfortable temperature range
                    this.energy = Math.max(0, this.energy - 0.8 * deltaTime); // More energy drain in uncomfortable temps
                    
                    // Temperature causes health damage at less extreme values
                    if (this.temperature < 3 || this.temperature > 37) {
                        this.health = Math.max(0, this.health - 0.3 * deltaTime); // Tripled from 0.1
                    }
                    
                    // Severe temperature causes more severe health damage
                    if (this.temperature < 0 || this.temperature > 40) {
                        this.health = Math.max(0, this.health - 0.6 * deltaTime); // Six times original value
                    }
                }
                
                // Natural health regeneration only when ALL conditions are excellent
                if (this.hunger > 85 && this.energy > 85 && this.temperature >= 15 && this.temperature <= 25) {
                    this.health = Math.min(100, this.health + 0.02 * deltaTime); // Reduced regen rate
                }
                
                // Update mood based on other stats
                this.updateMood();
                
                // Check for evolution
                this.checkEvolution();
                
                // Return health status for game state checking
                return this.health;
            }
            
            updateMood() {
                // Mood is affected by all stats
                // Formula: weighted average of hunger, energy, temperature comfort, and health
                const tempComfort = 1 - Math.abs(this.temperature - 20) / 30; // 1 at 20°C, 0 at extremes
                
                this.mood = (
                    0.3 * (this.hunger / 100) + 
                    0.2 * (this.energy / 100) + 
                    0.2 * tempComfort +
                    0.3 * (this.health / 100)
                ) * 100; // Convert to 0-100 scale
            }
            
            // Methods to modify stats
            feed(amount, foodType) {
                // Increase hunger when eating - multiply amount by 2 (reduced from 3)
                const amplifiedAmount = amount * 2;
                this.hunger = Math.min(100, this.hunger + amplifiedAmount);
                
                // Increment food counter for evolution check
                this.foodCounter++;
                
                // Track food consumption
                if (foodType && this.foodConsumed.hasOwnProperty(foodType)) {
                    this.foodConsumed[foodType]++;
                    
                    // Gain experience when eating food
                    this.gainExperience(amount * 0.8); // Reduced from 1.0 to slow evolution
                }
                
                // Return how much hunger was restored
                return amplifiedAmount;
            }
            
            rest(amount) {
                this.energy = Math.min(100, this.energy + amount);
            }
            
            heal(amount) {
                this.health = Math.min(100, this.health + amount);
            }
            
            changeTemperature(amount) {
                this.temperature = Math.max(-10, Math.min(45, this.temperature + amount));
            }
            
            gainExperience(amount) {
                this.experience += amount;
            }
            
            checkEvolution() {
                // Check if we've reached the next evolution threshold
                const nextThreshold = this.experienceThresholds[this.evolutionLevel];
                if (nextThreshold && this.experience >= nextThreshold) {
                    this.evolutionLevel++;
                    return true;
                }
                return false;
            }
            
            // Get the dominant biome based on exposure time
            getDominantBiome() {
                let maxExposure = 0;
                let dominantBiome = null;
                
                for (const [biome, exposure] of Object.entries(this.biomeExposure)) {
                    if (exposure > maxExposure) {
                        maxExposure = exposure;
                        dominantBiome = biome;
                    }
                }
                
                return dominantBiome;
            }
            
            // Get the favorite food based on consumption
            getFavoriteFood() {
                let maxConsumed = 0;
                let favoriteFood = null;
                
                for (const [food, count] of Object.entries(this.foodConsumed)) {
                    if (count > maxConsumed) {
                        maxConsumed = count;
                        favoriteFood = food;
                    }
                }
                
                return favoriteFood;
            }
            
            // Get evolution details
            getEvolutionDetails() {
                const dominantBiome = this.getDominantBiome();
                const favoriteFood = this.getFavoriteFood();
                
                return {
                    level: this.evolutionLevel,
                    dominantBiome,
                    favoriteFood,
                    experienceProgress: this.getExperienceProgress()
                };
            }
            
            // Get experience progress as a percentage to next level
            getExperienceProgress() {
                const currentThreshold = this.evolutionLevel > 0 
                    ? this.experienceThresholds[this.evolutionLevel - 1] 
                    : 0;
                const nextThreshold = this.experienceThresholds[this.evolutionLevel] || Infinity;
                const levelExperience = nextThreshold - currentThreshold;
                const currentLevelExperience = this.experience - currentThreshold;
                
                return Math.min(100, (currentLevelExperience / levelExperience) * 100);
            }

            // Method to add XP from food
            gainExperienceFromFood(nutrientValue, foodType) {
                // Grant XP equal to the food's nutrient value
                // Berries: 15 XP, Nuts: 20 XP, Cactus: 10 XP, Fish: 25 XP, Minerals: 5 XP
                this.experience += nutrientValue;
                this.foodCounter++;
                return this.checkEvolution(); // Return true if evolution happens
            }
            
            // Update the checkFoodEvolution method to remove instant evolution
            checkFoodEvolution() {
                // Simply increment counters but don't automatically evolve
                // Evolution is now handled through normal XP gain
                return false; // No longer triggers instant evolution
            }
        }

        // Blob class
        class Blob {
            constructor(x, y, world) {  // Add world parameter
                this.x = x;
                this.y = y;
                this.world = world;     // Store world reference
                this.radius = 18;       // Increased by 20% from 15 to 18
                this.color = '#4A148C'; // Changed to match the core color (deep purple)
                this.glowColor = '#4A148C'; // Changed to match the core color (deep purple)
                this.coreColor = '#4A148C'; // Deep purple core
                this.speed = 0.8; // Slightly faster base speed, but still much slower than player (speed 4)
                this.keys = {
                    ArrowUp: false,
                    ArrowDown: false,
                    ArrowLeft: false,
                    ArrowRight: false
                };

                // Animation properties
                this.pulseTime = 0;
                this.pulseFactor = 1;
                this.rotationAngle = 0;
                this.lastUpdateTime = Date.now();

                // Add stats to the blob
                this.stats = new Stats();
                
                // Current biome the blob is in
                this.currentBiome = null;
                
                // Message system for showing popups
                this.messages = [];
                
                // Evolution traits
                this.traits = {
                    spikes: false,        // Desert adaptation
                    fins: false,          // Water adaptation
                    furCoat: false,       // Mountain adaptation
                    camouflage: false,    // Forest adaptation
                    size: 1.0,            // Size multiplier
                    glowingSpots: false   // Aesthetic feature for higher levels
                };
                
                // Visual effects
                this.evolutionFlash = false;
                
                // Add an inventory
                this.inventory = new Inventory();
                
                // Add collection mode
                this.collectionMode = false;
                this.collectionRadius = 120; // Dramatically increased from 40 to 120
                
                // Building mode properties
                this.isBuildMode = false;
                this.selectedBuildingType = 'house';
                this.buildingTypes = ['house', 'farm', 'tower', 'workshop'];
                this.buildingTypeIndex = 0;
                
                // Add pet properties
                this.isPet = false; // Flag to indicate if the blob is a tamed pet
                this.owner = null; // Reference to the person who owns the blob
                this.petName = "Blobby"; // Default pet name
                this.tamingProgress = 0; // Progress toward taming (0-100)
                this.petEvolutions = [
                    "Wild Blob", // Level 0
                    "Tamed Blob", // Level 1
                    "Friendly Blob", // Level 2
                    "Loyal Blob", // Level 3
                    "Companion Blob", // Level 4
                    "Guardian Blob" // Level 5+
                ];
                
                this.setupControls();
                
                // Setup mouse click handler for inventory
                window.addEventListener('click', (e) => {
                    const rect = document.getElementById('gameCanvas').getBoundingClientRect();
                    const canvasX = e.clientX - rect.left;
                    const canvasY = e.clientY - rect.top;
                    
                    // Handle inventory click
                    if (this.inventory.visible) {
                        // Always use document.getElementById to get the canvas
                        const canvas = document.getElementById('gameCanvas');
                        this.inventory.handleClick(canvasX, canvasY, canvas.width, canvas.height);
                        // activeFood is now updated via the inventorySelectionChanged event
                    }
                });
                
                // Listen for inventory selection changes
                window.addEventListener('inventorySelectionChanged', (e) => {
                    console.log('Inventory selection changed:', e.detail);
                    // Update active food based on selected item
                    const selectedItem = this.inventory.selectedItem ? 
                                        this.inventory.items[this.inventory.selectedItem] : null;
                    
                    if (selectedItem && selectedItem.type === 'resource') {
                        this.activeFood = {
                            type: selectedItem.name,
                            nutrientValue: 10,
                            energyValue: 5
                        };
                        
                        // Update food circle color based on food type
                        switch(selectedItem.name.toLowerCase()) {
                            case 'berries': this.foodCircle.color = '#CC0066'; break;
                            case 'nuts': this.foodCircle.color = '#8B4513'; break;
                            case 'cactus': this.foodCircle.color = '#7FFF00'; break;
                            case 'fish': this.foodCircle.color = '#4682B4'; break;
                            case 'minerals': this.foodCircle.color = '#B8B8B8'; break;
                            default: this.foodCircle.color = '#FFFFFF';
                        }
                        console.log('Updated active food:', this.activeFood);
                        this.showMessage(`Selected ${selectedItem.name} for feeding`);
                    } else {
                        // Clear active food if no valid item is selected
                        this.activeFood = null;
                        console.log('No valid food item selected');
                        if (this.isFeeding) {
                            this.isFeeding = false;
                            this.showMessage('Feeding stopped');
                        }
                    }
                });
            }
            
            showMessage(text, duration = 1500) {
                // Initialize messages array if it doesn't exist
                if (!this.messages) {
                    this.messages = [];
                }
                
                // Limit the number of messages to prevent buildup
                if (this.messages.length >= 5) {
                    // Remove oldest message if we have too many
                    this.messages.shift();
                }
                
                // Filter out any duplicate messages with the same text
                this.messages = this.messages.filter(msg => msg.text !== text);
                
                // Add a new message with the specified duration
                this.messages.push({
                    text: text,
                    x: this.x,
                    y: this.y - 20, // Position above the person
                    alpha: 1.0, // Full opacity
                    duration: duration, // Duration in milliseconds
                    startTime: Date.now() // Add start time immediately
                });
            }

            setupControls() {
                window.addEventListener('keydown', (e) => {
                    if (this.keys.hasOwnProperty(e.key)) {
                        this.keys[e.key] = true;
                    }
                    
                    // Toggle build mode with B key
                    if (e.code === 'KeyB') {
                        this.isBuildMode = !this.isBuildMode;
                        // Turn off collection mode when entering build mode
                        if (this.isBuildMode) this.collectionMode = false;
                        this.showMessage(this.isBuildMode ? "Build mode ON" : "Build mode OFF", 2000);
                    }
                    
                    // Cycle through building types with N key
                    if (e.code === 'KeyN' && this.isBuildMode) {
                        this.buildingTypeIndex = (this.buildingTypeIndex + 1) % this.buildingTypes.length;
                        this.selectedBuildingType = this.buildingTypes[this.buildingTypeIndex];
                        this.showMessage(`Selected: ${this.selectedBuildingType}`, 2000);
                    }
                    
                    // Name pet only happens when not in build mode
                    if (e.code === 'KeyN' && !this.isBuildMode && this.isPet) {
                        // This is handled in the Game class
                    }
                });

                window.addEventListener('keyup', (e) => {
                    if (this.keys.hasOwnProperty(e.key)) {
                        this.keys[e.key] = false;
                    }
                });
            }

            update(worldWidth, worldHeight, biomeManager) {
                try {
                    // Get current biome if biomeManager is available
                    if (biomeManager) {
                        this.currentBiome = biomeManager.getBiomeAt(this.x, this.y);
                    } else if (this.world && this.world.biomeManager) {
                        this.currentBiome = this.world.biomeManager.getBiomeAt(this.x, this.y);
                    }

                    // Use default biome if none found
                    if (!this.currentBiome) {
                        this.currentBiome = { type: 'Forest', color: '#228B22', temperatureEffect: 0.5 };
                    }
                    
                    // Determine if the blob is moving this frame
                    const isMoving = this.keys.ArrowUp || this.keys.ArrowDown || 
                                    this.keys.ArrowLeft || this.keys.ArrowRight;
                    
                    // Update stats with current biome and movement state
                    const healthStatus = this.stats.update(this.currentBiome, isMoving);
                    
                    // Check if blob is dead (health reaches 0)
                    if (healthStatus <= 0) {
                        this.handleDeath();
                        return;
                    }
                    
                    // Slow down when energy is low
                    let energyFactor = Math.max(0.5, this.stats.energy / 100);
                    
                    // Biome-specific factors
                    let biomeFactor = 1;
                    if (this.currentBiome) {
                        // Water movement
                        if (this.currentBiome.type === 'Water') {
                            biomeFactor = this.traits.fins ? 1.2 : 0.6; // Restored from 0.8 back to 0.6 for more slowdown
                        }
                        // Desert movement
                        else if (this.currentBiome.type === 'Desert') {
                            biomeFactor = this.traits.spikes ? 1.1 : 0.8; // Faster with spikes
                        }
                        // Mountain movement - affected by temperature
                        else if (this.currentBiome.type === 'Mountains') {
                            if (this.stats.temperature < 5) {
                                biomeFactor = this.traits.furCoat ? 0.9 : 0.7; // Less slowdown with fur
                            }
                        }
                    }
                    
                    // Health affects movement too - when health is low, movement gets harder
                    const healthFactor = this.stats.health > 30 ? 1 : this.stats.health / 30;
                    
                    const currentSpeed = this.speed * energyFactor * biomeFactor * healthFactor;
                    
                    // Movement
                    if (this.keys.ArrowUp) this.y -= currentSpeed;
                    if (this.keys.ArrowDown) this.y += currentSpeed;
                    if (this.keys.ArrowLeft) this.x -= currentSpeed;
                    if (this.keys.ArrowRight) this.x += currentSpeed;

                    // World wrap-around (sphere-like)
                    if (this.x < 0) this.x = worldWidth;
                    if (this.x > worldWidth) this.x = 0;
                    if (this.y < 0) this.y = worldHeight;
                    if (this.y > worldHeight) this.y = 0;
                    
                    // Gradually adapt blob color to biome
                    if (this.currentBiome) {
                        this.adaptToBiome();
                    }
                    
                    // Update messages
                    this.updateMessages();
                    
                    // Show a debug message about current XP if it's close to evolving
                    const nextThreshold = this.stats.experienceThresholds[this.stats.evolutionLevel];
                    if (nextThreshold && this.stats.experience > nextThreshold - 30) {
                        // Show how close we are to evolving
                        const remaining = nextThreshold - this.stats.experience;
                        if (remaining > 0 && remaining <= 30) {
                            // Round the remaining XP to avoid long floating-point numbers
                            const roundedRemaining = Math.ceil(remaining);
                            this.showMessage(`XP: ${Math.round(this.stats.experience)}/${nextThreshold} (${roundedRemaining} to go)`, 1000);
                        }
                    }
                } catch (error) {
                    console.error('Error in update:', error);
                }
            }
            
            handleDeath() {
                console.log('Handling death...');
                this.isDead = true;
                this.color = '#404040';

                // Remove any existing death screen first
                const existing = document.getElementById('deathOverlay');
                if (existing) {
                    existing.remove();
                }

                // Create death screen container
                const container = document.createElement('div');
                container.id = 'deathOverlay';
                container.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background-color: rgba(0, 0, 0, 0.8);
                    padding: 20px;
                    border-radius: 10px;
                    text-align: center;
                    z-index: 1000;
                `;

                // Add HTML directly
                container.innerHTML = `
                    <div style="color: white; font-size: 24px; margin-bottom: 20px;">
                        Your blob has died...
                    </div>
                    <button id="restartButton" style="
                        padding: 10px 20px;
                        font-size: 18px;
                        background-color: #4CAF50;
                        color: white;
                        border: none;
                        border-radius: 5px;
                        cursor: pointer;
                        margin: 10px;
                    ">
                        Restart Game
                    </button>
                    <div style="color: white; font-size: 14px; margin-top: 10px;">
                        Press 'R' key to restart
                    </div>
                `;

                // Add to document
                document.body.appendChild(container);
                console.log('Death screen added');

                // Add click handler after the element is in the DOM
                const self = this;
                const button = document.getElementById('restartButton');
                if (button) {
                    console.log('Found restart button, adding handlers');
                    
                    // Try multiple ways to add click handler
                    button.onclick = function(e) {
                        console.log('Button clicked (onclick)');
                        self.resetBlob();
                        container.remove();
                    };

                    button.addEventListener('click', function(e) {
                        console.log('Button clicked (addEventListener)');
                        self.resetBlob();
                        container.remove();
                    }, false);

                    // Also try mousedown event
                    button.addEventListener('mousedown', function(e) {
                        console.log('Button mousedown');
                        self.resetBlob();
                        container.remove();
                    }, false);

                    // Make button more obvious it's clickable
                    button.addEventListener('mouseover', function() {
                        this.style.backgroundColor = '#45a049';
                    });
                    
                    button.addEventListener('mouseout', function() {
                        this.style.backgroundColor = '#4CAF50';
                    });
                } else {
                    console.error('Could not find restart button!');
                }
            }
            
            resetBlob() {
                console.log('Starting blob reset with world:', this.world);
                
                // Reset stats
                this.stats = new Stats();
                console.log('Stats reset');
                
                // Reset position to center of the world
                const worldSize = this.world.biomeManager.getWorldSize();
                console.log('World dimensions:', worldSize);
                this.x = worldSize.width / 2;
                this.y = worldSize.height / 2;
                console.log('New position:', { x: this.x, y: this.y });
                
                // Reset appearance
                this.radius = 18;  // Increased by 20% from 15 to 18
                this.color = '#4A148C';
                this.glowColor = '#4A148C'; // Changed to match the core color (deep purple)
                this.coreColor = '#4A148C';
                this.speed = 0.8;
                console.log('Appearance reset');
                
                // Reset evolution traits
                this.traits = {
                    spikes: false,
                    fins: false,
                    furCoat: false,
                    camouflage: false,
                    size: 1.0,
                    glowingSpots: false
                };
                console.log('Traits reset');
                
                // Reset inventory and modes
                this.inventory = new Inventory();
                this.collectionMode = false;
                this.isBuildMode = false;
                this.isDead = false;
                console.log('Inventory and modes reset');
                
                // Reset all movement keys
                Object.keys(this.keys).forEach(key => {
                    this.keys[key] = false;
                });
                console.log('Movement keys reset');
                
                this.showMessage("Blob reborn!", 3000);
                console.log('Blob reset completed successfully');
            }
            
            updateMessages() {
                // Ensure messages array exists
                if (!this.messages || !Array.isArray(this.messages)) {
                    this.messages = [];
                    return;
                }
                
                const now = Date.now();
                
                // Update each message
                for (let i = this.messages.length - 1; i >= 0; i--) {
                    const message = this.messages[i];
                    
                    // Check if message has required properties
                    if (!message || !message.startTime) {
                        this.messages.splice(i, 1);
                        continue;
                    }
                    
                    const elapsed = now - message.startTime;
                    
                    if (elapsed >= message.duration) {
                        // Remove expired message
                        this.messages.splice(i, 1);
                    } else {
                        // Update position and fade
                        message.y -= 0.5; // Float upward
                        message.alpha = 1.0 - (elapsed / message.duration); // Fade out
                    }
                }
            }
            
            adaptToBiome() {
                // Gradually change color based on biome
                const targetColor = this.currentBiome.color;
                const currentColor = this.color;
                
                // Parse colors to RGB
                const getRGB = (color) => {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return [r, g, b];
                };
                
                const currentRGB = getRGB(currentColor);
                const targetRGB = getRGB(targetColor);
                
                // Slowly transition to target color (5% per second)
                const newRGB = currentRGB.map((c, i) => {
                    const diff = targetRGB[i] - c;
                    return Math.round(c + diff * 0.005);
                });
                
                // Convert back to hex
                this.color = `#${newRGB.map(c => c.toString(16).padStart(2, '0')).join('')}`;
            }

            draw(ctx, cameraX, cameraY) {
                // Calculate screen position
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Ensure messages array exists
                if (!this.messages || !Array.isArray(this.messages)) {
                    this.messages = [];
                }
                
                // Remove any debugging messages that contain evolution information or XP info
                this.messages = this.messages.filter(msg => {
                    // Filter out any debug messages containing "to evolve" with unrounded numbers
                    const containsEvolveInfo = msg.text && typeof msg.text === 'string' && 
                                            msg.text.includes('to evolve') && 
                                            /\d+\.\d{5,}/.test(msg.text);
                    
                    // Also filter out any XP-related messages that might be causing shadows
                    const containsXpInfo = msg.text && typeof msg.text === 'string' && 
                                         msg.text.includes('XP:') && 
                                         msg.text.includes('to go');
                    
                    // Keep message only if it doesn't contain either type of problematic content
                    return !(containsEvolveInfo || containsXpInfo);
                });
                
                // Update animation properties
                const now = Date.now();
                const deltaTime = (now - this.lastUpdateTime) / 1000;
                this.lastUpdateTime = now;
                
                // Update pulse
                this.pulseTime += deltaTime * 2;
                this.pulseFactor = 1 + Math.sin(this.pulseTime) * 0.1;
                
                // Update rotation
                this.rotationAngle += deltaTime * 0.5;
                
                // Draw glow effect
                const glowRadius = this.radius * 1.5 * this.pulseFactor;
                const gradient = ctx.createRadialGradient(
                    screenX, screenY, this.radius * 0.5,
                    screenX, screenY, glowRadius
                );
                // Convert hex color #4A148C to rgba with 25% opacity (0.25)
                gradient.addColorStop(0, 'rgba(74, 20, 140, 0.25)'); // Using rgba for deep purple color with opacity
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.beginPath();
                ctx.arc(screenX, screenY, glowRadius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Draw evolution flash if active
                if (this.evolutionFlash) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.radius * 2, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, ' + (Math.random() * 0.5 + 0.2) + ')';
                    ctx.fill();
                    ctx.closePath();
                }
                
                // Draw collection radius if collection mode is active
                if (this.collectionMode) {
                    // Main collection circle
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.collectionRadius, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(0, 255, 0, 0.6)'; // Increased opacity from 0.5 to 0.6
                    ctx.lineWidth = 4; // Increased from 3 to 4
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.1)'; // Add a light fill
                    ctx.fill();
                    ctx.closePath();
                    
                    // Add a more dynamic pulsing effect
                    const pulseTime = Date.now() / 300;
                    for (let i = 0; i < 3; i++) {
                        const pulsePhase = pulseTime + i * Math.PI / 3;
                        const pulseRadius = this.collectionRadius * (0.7 + Math.sin(pulsePhase) * 0.3);
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, pulseRadius, 0, Math.PI * 2);
                        const opacity = 0.7 - (i * 0.2);
                        ctx.strokeStyle = `rgba(0, 255, 0, ${opacity})`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.closePath();
                    }
                    
                    // Add text to make it clear
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 16px Arial'; // Make text larger and bold
                    ctx.textAlign = 'center';
                    ctx.fillText('Collection Mode Active', screenX, screenY - this.radius - 25);
                    ctx.fillText('Food auto-collected within circle', screenX, screenY - this.radius - 5);
                }
                
                // Draw build mode indicator
                if (this.isBuildMode) {
                    // Draw a building outline preview
                    ctx.strokeStyle = 'rgba(0, 255, 0, 0.7)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenX - 30, screenY - 25, 60, 50);
                    
                    // Show selected building type
                    ctx.fillStyle = 'white';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Build: ${this.selectedBuildingType}`, screenX, screenY - this.radius - 40);
                }
                
                // Draw blob main body
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.radius * this.pulseFactor, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                // Draw blob core
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.radius * 0.6 * this.pulseFactor, 0, Math.PI * 2);
                ctx.fillStyle = this.coreColor;
                ctx.fill();
                
                // Draw swirl effects with smaller size and moved to edges
                for (let i = 0; i < 3; i++) {
                    const angle = this.rotationAngle + (i * Math.PI * 2 / 3);
                    const orbitRadius = this.radius * 0.65 * this.pulseFactor; // Increased from 0.5 to 0.65 to move to edges
                    const swirlX = screenX + Math.cos(angle) * orbitRadius;
                    const swirlY = screenY + Math.sin(angle) * orbitRadius;
                    
                    ctx.beginPath();
                    ctx.arc(swirlX, swirlY, this.radius * 0.15, 0, Math.PI * 2); // Reduced from 0.2 to 0.15
                    ctx.fillStyle = '#4A148C'; // Changed to match the core color (deep purple)
                    ctx.fill();
                }
                
                // If blob is dead, draw X eyes
                if (this.isDead) {
                    this.drawDeadFace(ctx, screenX, screenY);
                } else {
                    // Draw evolution features
                    this.drawEvolutionFeatures(ctx, screenX, screenY);
                    
                    // Draw pet status and name if it's a pet
                    if (this.isPet) {
                        // Draw pet name above the blob
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(this.petName, screenX, screenY - this.radius - 20);
                        
                        // Draw pet evolution level
                        const petEvoLevel = Math.min(this.petEvolutions.length - 1, this.stats.evolutionLevel);
                        ctx.font = '12px Arial';
                        ctx.fillText(this.petEvolutions[petEvoLevel], screenX, screenY - this.radius - 5);
                    } else if (this.tamingProgress > 0) {
                        // Draw taming progress if not fully tamed
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`Taming: ${this.tamingProgress}%`, screenX, screenY - this.radius - 5);
                    }
                    
                    // Draw blob face
                    this.drawFace(ctx, screenX, screenY);
                }
                
                // Draw messages
                this.drawMessages(ctx, cameraX, cameraY);
                
                // Draw inventory if visible
                // Use ctx.canvas directly to get dimensions instead of relying on this.canvas
                this.inventory.draw(ctx, ctx.canvas.width, ctx.canvas.height);
            }
            
            drawFace(ctx, x, y) {
                // Draw eyes
                const eyeRadius = this.radius * 0.15;
                const eyeOffsetX = this.radius * 0.25; // Reduced from 0.3 to 0.25 to keep eyes more centered
                const eyeOffsetY = this.radius * 0.15; // Reduced from 0.2 to 0.15 to move eyes up slightly
                
                // White of the eyes
                ctx.beginPath();
                ctx.arc(x - eyeOffsetX, y - eyeOffsetY, eyeRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#FFFFFF';
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(x + eyeOffsetX, y - eyeOffsetY, eyeRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#FFFFFF';
                ctx.fill();
                
                // Pupils - follow a slight circular motion
                const pupilRadius = eyeRadius * 0.6;
                const pupilOffsetFactor = 0.3;
                const pupilAngle = Date.now() / 2000; // Slow rotation
                
                // Left pupil
                ctx.beginPath();
                ctx.arc(
                    x - eyeOffsetX + Math.cos(pupilAngle) * pupilRadius * pupilOffsetFactor,
                    y - eyeOffsetY + Math.sin(pupilAngle) * pupilRadius * pupilOffsetFactor,
                    pupilRadius,
                    0, Math.PI * 2
                );
                ctx.fillStyle = '#000000';
                ctx.fill();
                
                // Right pupil
                ctx.beginPath();
                ctx.arc(
                    x + eyeOffsetX + Math.cos(pupilAngle + Math.PI) * pupilRadius * pupilOffsetFactor,
                    y - eyeOffsetY + Math.sin(pupilAngle + Math.PI) * pupilRadius * pupilOffsetFactor,
                    pupilRadius, 
                    0, Math.PI * 2
                );
                ctx.fillStyle = '#000000';
                ctx.fill();
                
                // Mouth - changes based on mood
                const moodPercent = this.stats.mood / 100;
                
                // Adjustable smile based on mood - moved down slightly
                const mouthY = y + eyeOffsetY + 2; // Added +2 to move mouth down slightly
                const smileHeight = moodPercent * 6; // Max height of smile curve
                const mouthWidth = this.radius * 0.6;
                
                ctx.beginPath();
                ctx.moveTo(x - mouthWidth/2, mouthY);
                
                // Create a quadratic curve (smile or frown based on mood)
                ctx.quadraticCurveTo(
                    x, // control point x
                    mouthY + smileHeight, // control point y 
                    x + mouthWidth/2, // end point x
                    mouthY // end point y
                );
                
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            drawEvolutionFeatures(ctx, x, y) {
                // Draw spikes if evolved
                if (this.traits.spikes) {
                    const spikeLength = this.radius * 0.4;
                    const numSpikes = 8;
                    
                    ctx.strokeStyle = '#B8860B'; // Dark goldenrod
                    ctx.lineWidth = 2;
                    
                    for (let i = 0; i < numSpikes; i++) {
                        const angle = (i / numSpikes) * Math.PI * 2;
                        const startX = x + Math.cos(angle) * this.radius;
                        const startY = y + Math.sin(angle) * this.radius;
                        const endX = x + Math.cos(angle) * (this.radius + spikeLength);
                        const endY = y + Math.sin(angle) * (this.radius + spikeLength);
                        
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                    }
                }
                
                // Draw fins if evolved
                if (this.traits.fins) {
                    const finWidth = this.radius * 0.8;
                    const finHeight = this.radius * 0.6;
                    
                    // Draw left fin
                    ctx.fillStyle = 'rgba(30, 144, 255, 0.7)'; // Semi-transparent blue
                    ctx.beginPath();
                    ctx.ellipse(
                        x - this.radius * 0.8, 
                        y, 
                        finWidth / 2, 
                        finHeight / 2, 
                        -Math.PI / 4, 
                        0, 
                        Math.PI * 2
                    );
                    ctx.fill();
                    
                    // Draw right fin
                    ctx.beginPath();
                    ctx.ellipse(
                        x + this.radius * 0.8, 
                        y, 
                        finWidth / 2, 
                        finHeight / 2, 
                        Math.PI / 4, 
                        0, 
                        Math.PI * 2
                    );
                    ctx.fill();
                }
                
                // Draw fur if evolved
                if (this.traits.furCoat) {
                    ctx.fillStyle = 'rgba(139, 69, 19, 0.3)'; // Semi-transparent brown
                    ctx.beginPath();
                    ctx.arc(x, y, this.radius * 1.15, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw camouflage if evolved
                if (this.traits.camouflage) {
                    const numPatches = 5;
                    ctx.fillStyle = 'rgba(34, 139, 34, 0.5)'; // Semi-transparent green
                    
                    for (let i = 0; i < numPatches; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * this.radius * 0.7;
                        const patchX = x + Math.cos(angle) * distance;
                        const patchY = y + Math.sin(angle) * distance;
                        const patchSize = this.radius * 0.3;
                        
                        ctx.beginPath();
                        ctx.arc(patchX, patchY, patchSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Draw glowing spots if evolved
                if (this.traits.glowingSpots) {
                    const numSpots = 6;
                    const spotSize = this.radius * 0.15;
                    
                    for (let i = 0; i < numSpots; i++) {
                        const angle = (i / numSpots) * Math.PI * 2;
                        const spotX = x + Math.cos(angle) * (this.radius * 0.7);
                        const spotY = y + Math.sin(angle) * (this.radius * 0.7);
                        
                        // Gradient for glow effect
                        const gradient = ctx.createRadialGradient(
                            spotX, spotY, 0,
                            spotX, spotY, spotSize
                        );
                        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                        gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(spotX, spotY, spotSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            drawDeadFace(ctx, x, y) {
                const eyeOffset = this.radius * 0.3;
                
                // Draw X eyes
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                
                // Left eye X
                ctx.beginPath();
                ctx.moveTo(x - eyeOffset - 5, y - eyeOffset - 5);
                ctx.lineTo(x - eyeOffset + 5, y - eyeOffset + 5);
                ctx.moveTo(x - eyeOffset + 5, y - eyeOffset - 5);
                ctx.lineTo(x - eyeOffset - 5, y - eyeOffset + 5);
                ctx.stroke();
                
                // Right eye X
                ctx.beginPath();
                ctx.moveTo(x + eyeOffset - 5, y - eyeOffset - 5);
                ctx.lineTo(x + eyeOffset + 5, y - eyeOffset + 5);
                ctx.moveTo(x + eyeOffset + 5, y - eyeOffset - 5);
                ctx.lineTo(x + eyeOffset - 5, y - eyeOffset + 5);
                ctx.stroke();
                
                // Straight line mouth
                ctx.beginPath();
                ctx.moveTo(x - this.radius * 0.3, y + this.radius * 0.2);
                ctx.lineTo(x + this.radius * 0.3, y + this.radius * 0.2);
                ctx.stroke();
            }
            
            drawMessages(ctx, cameraX, cameraY) {
                // Check if messages array exists
                if (!this.messages || !Array.isArray(this.messages)) {
                    this.messages = [];
                    return;
                }
                
                // First, make sure we don't have more than 5 messages at once to prevent clutter
                if (this.messages.length > 5) {
                    // Keep only the 5 newest messages
                    this.messages = this.messages.slice(-5);
                }
                
                ctx.textAlign = 'center';
                ctx.font = '14px Arial';
                
                // Create a small offset for message positions to prevent overlap
                let messageOffset = 0;
                
                this.messages.forEach((message, index) => {
                    // Calculate screen position for the message
                    const screenX = message.x - cameraX;
                    const screenY = message.y - cameraY - (messageOffset * index);
                    
                    // Draw message with fading effect
                    ctx.fillStyle = `rgba(255, 255, 255, ${message.alpha})`;
                    ctx.strokeStyle = `rgba(0, 0, 0, ${message.alpha})`;
                    ctx.lineWidth = 2;
                    
                    // Draw text stroke for better visibility, using a shadow instead of stroke
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    
                    // Draw main text
                    ctx.fillText(message.text, screenX, screenY);
                    
                    // Reset shadow to prevent it from affecting other drawing operations
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                });
                
                // Reset text alignment
                ctx.textAlign = 'left';
            }
            
            checkEvolution() {
                return this.stats.checkEvolution();
            }
            
            evolve(evolutionDetails) {
                const { level, dominantBiome, favoriteFood } = evolutionDetails;
                
                // Determine evolution traits based on the dominant biome and food
                let newTraits = [];
                
                // Base size increase with each evolution, but cap it after level 10
                if (level <= 10) {
                    this.radius = 18 + (level * 1.8); // Adjusted from 15 + (level * 1.5) to match the 20% size increase
                }
                
                // Increase inventory size every 3 levels
                if (level % 3 === 0) {
                    this.inventory.upgradeCapacity(4);
                    newTraits.push('Inventory +4 slots');
                }
                
                // Guarantee speed increase with each level - base speed starts at 0.8
                // Calculate new speed with a consistent increase per level
                let baseIncrease = 0.15; // 0.15 speed boost per level
                
                // Calculate normal speed before any special adjustments
                let normalSpeed = 0.8 + (level * baseIncrease);
                
                // Speed adjustment based on evolution level
                const dogSpeed = 4; // Dog's speed for reference
                const maxBlobSpeed = dogSpeed * 0.8; // Blob should be at most 80% of dog's speed
                
                if (level >= 3) {
                    // For level 3 (Loyal), set to exactly 1.7
                    if (level === 3) {
                        this.speed = 1.7;
                        newTraits.push(`Speed: ${this.speed.toFixed(2)} (Faster!)`);
                    } 
                    // For level 4 (Companion), set to exactly 2.1
                    else if (level === 4) {
                        this.speed = 2.1;
                        newTraits.push(`Speed: ${this.speed.toFixed(2)} (Even Faster!)`);
                    }
                    // For level 5+ (Guardian), set to exactly 2.5
                    else if (level >= 5) {
                        this.speed = 2.5;
                        newTraits.push(`Speed: ${this.speed.toFixed(2)} (Maximum Speed)`);
                    }
                } else {
                    // Lower levels use normal speed calculation
                    this.speed = Math.min(2.0, normalSpeed);
                    newTraits.push(`Speed: ${this.speed.toFixed(2)}`);
                }
                
                // Different evolution paths based on level
                if (level <= 5) {
                    // Early evolutions - add traits but don't change the guaranteed speed boost
                    switch(level) {
                        case 1:
                            // First evolution - adapt to dominant biome
                            if (dominantBiome === 'Desert') {
                                this.traits.spikes = true;
                                newTraits.push('Spikes');
                            } else if (dominantBiome === 'Water') {
                                this.traits.fins = true;
                                newTraits.push('Fins');
                            } else if (dominantBiome === 'Mountains') {
                                this.traits.furCoat = true;
                                newTraits.push('Fur Coat');
                            } else if (dominantBiome === 'Forest') {
                                this.traits.camouflage = true;
                                newTraits.push('Camouflage');
                            }
                            break;
                            
                        case 2:
                            // Second evolution - adapt based on diet
                            if (favoriteFood === 'fish') {
                                this.traits.fins = true;
                                newTraits.push('Fins');
                            } else if (favoriteFood === 'berries' || favoriteFood === 'nuts') {
                                this.traits.size = 1.2;
                                newTraits.push('Increased Size');
                            } else if (favoriteFood === 'minerals') {
                                this.traits.spikes = true; // Mineral-based spikes
                                newTraits.push('Mineral Spikes');
                            }
                            break;
                            
                        case 3:
                            // Third evolution - special abilities (Loyal Blob)
                            this.traits.glowingSpots = true;
                            newTraits.push('Glowing Spots');
                            this.traits.size = 1.5;
                            newTraits.push('Advanced Size');
                            // Scaled speed boost is already applied in the earlier code (50% boost at this level)
                            break;
                            
                        case 4:
                            // Fourth evolution - mastery of environment
                            this.traits.spikes = true;
                            this.traits.fins = true;
                            this.traits.furCoat = true;
                            this.traits.camouflage = true;
                            newTraits.push('Environmental Mastery');
                            break;
                            
                        case 5:
                            // Fifth evolution - advanced blob
                            this.traits.size = 2.0;
                            this.radius = 30; // Reduced from 40 to 30
                            newTraits.push('Advanced Blob Form');
                            break;
                    }
                } else {
                    // Higher level evolutions - add new traits based on level
                    // Every odd level adds a random trait
                    if (level % 2 === 1) {
                        const traits = ['Armor', 'Tentacles', 'Venom', 'Telepathy', 'Magnetism', 
                                        'Regeneration', 'Shapeshifting', 'Teleportation', 'Force Field'];
                        const randomTrait = traits[Math.floor(Math.random() * traits.length)];
                        newTraits.push(randomTrait);
                    }
                }
                
                // Show more prominent evolution message with longer duration
                this.showMessage(`★ EVOLUTION! LEVEL ${level} ★`, 5000);
                
                // Show traits message after a short delay, with longer duration
                if (newTraits.length > 0) {
                    setTimeout(() => {
                        this.showMessage(`New traits: ${newTraits.join(', ')}`, 5000);
                    }, 2000);
                }
                
                // Add visual flash effect
                this.evolutionFlash = true;
                setTimeout(() => {
                    this.evolutionFlash = false;
                }, 1000);
            }
            
            // Method to consume food given by a person
            consumePersonFood(food) {
                // Apply food effects
                const hungerRestored = this.stats.feed(food.nutrientValue, food.type);
                this.stats.rest(food.energyValue);
                
                // Add experience directly from food (this was missing)
                this.stats.experience += food.nutrientValue;
                
                // Increase taming progress when fed
                if (!this.isPet) {
                    this.tamingProgress += 5;
                    if (this.tamingProgress >= 100) {
                        this.isPet = true;
                        this.tamingProgress = 100;
                        this.showMessage("You've tamed the blob!", 3000);
                    } else {
                        this.showMessage(`Taming: ${Math.floor(this.tamingProgress)}%`, 2000);
                    }
                } else {
                    // Already a pet, show happiness
                    this.showMessage("Yum! Thank you!", 2000);
                }
                
                // Show XP gain message - use food.nutrientValue for XP (not the amplified hunger value)
                this.showMessage(`+${food.nutrientValue} XP`, 1500);
                
                // Check for evolution after feeding
                let didEvolve = false;
                
                if (this.checkEvolution()) {
                    const currentLevel = this.stats.evolutionLevel;
                    const evolutionDetails = {
                        level: currentLevel,
                        dominantBiome: this.stats.dominantBiome,
                        favoriteFood: this.stats.favoriteFood
                    };
                    
                    console.log('Evolution triggered at level', currentLevel);
                    this.evolve(evolutionDetails);
                    didEvolve = true;
                    this.showMessage(`Evolved to level ${currentLevel}!`, 3000);
                }
                
                // After evolution, reset person's feeding state to prevent issues
                if (window.gameInstance && window.gameInstance.person) {
                    // Schedule this after a slight delay to prevent race conditions
                    setTimeout(() => {
                        // Store the current selected food and item
                        const person = window.gameInstance.person;
                        const currentSelectedItem = person.inventory.selectedItem;
                        const activeFood = person.activeFood;
                        
                        console.log('Selected item after evolution:', currentSelectedItem);
                        console.log('Active food after evolution:', activeFood);
                        
                        // Force an inventory update event to refresh the UI and prevent freeze
                        const event = new CustomEvent('inventorySelectionChanged', {
                            detail: {
                                selectedItem: currentSelectedItem,
                                previousSelectedItem: currentSelectedItem
                            }
                        });
                        window.dispatchEvent(event);
                        
                        // If feeding was in progress, make sure the food circle position is updated
                        if (person.isFeeding && person.activeFood) {
                            person.isFeeding = false;
                            
                            // Restart feeding after a short delay
                            setTimeout(() => {
                                person.isFeeding = true;
                                console.log('Restarting feeding process after evolution');
                                
                                // Calculate appropriate distance based on dog and blob size
                                const dogSizeMultiplier = 1.5;
                                const blobRadiusAdjustment = this.radius * 0.8;
                                
                                // Position the food circle with new size considerations
                                const foodCircleDistance = person.foodCircle.radius * 2 + 20 + blobRadiusAdjustment;
                                
                                // Reposition the food circle based on direction
                                switch(person.direction) {
                                    case 'up':
                                        person.foodCircle.x = person.x;
                                        person.foodCircle.y = person.y - person.height * dogSizeMultiplier - foodCircleDistance;
                                        break;
                                    case 'down':
                                        person.foodCircle.x = person.x;
                                        person.foodCircle.y = person.y + person.height * dogSizeMultiplier + foodCircleDistance;
                                        break;
                                    case 'left':
                                        person.foodCircle.x = person.x - person.width * dogSizeMultiplier - foodCircleDistance;
                                        person.foodCircle.y = person.y;
                                        break;
                                    case 'right':
                                        person.foodCircle.x = person.x + person.width * dogSizeMultiplier + foodCircleDistance;
                                        person.foodCircle.y = person.y;
                                        break;
                                }
                                console.log('Food circle repositioned after evolution');
                            }, 100);
                        }
                    }, 100);
                }
                
                return didEvolve;
            }

            // Add building related methods
            startBuilding(buildingType, buildingManager) {
                if (!this.isBuildMode) return false;
                
                // Check if we can afford and build at the current location
                if (buildingManager.canBuildAt(this.x - 30, this.y - 25, buildingType) && 
                    buildingManager.canAffordBuilding(buildingType, this.inventory)) {
                    
                    // Consume resources
                    if (buildingManager.consumeResources(buildingType, this.inventory)) {
                        // Add the new building
                        const building = buildingManager.addBuilding(this.x - 30, this.y - 25, buildingType);
                        
                        if (building) {
                            this.showMessage(`Started building a ${buildingType}!`, 3000);
                            return true;
                        }
                    } else {
                        this.showMessage("Not enough resources!", 2000);
                    }
                } else {
                    this.showMessage("Can't build here!", 2000);
                }
                
                return false;
            }
            
            workOnBuilding(building) {
                // Blob can work on buildings to complete them
                const constructionRate = 0.5 * (1 + this.stats.evolutionLevel * 0.1); // Faster with higher evolution
                
                if (!building.completed) {
                    const completed = building.continueConstruction(constructionRate);
                    
                    if (completed) {
                        this.showMessage(`${building.type} construction completed!`, 3000);
                        return true;
                    } else {
                        // Show occasional progress updates
                        if (Math.random() < 0.05) {
                            this.showMessage(`Building: ${Math.round(building.constructionProgress)}%`, 1000);
                        }
                    }
                }
                
                return false;
            }
        }

        // World class
        class World {
            constructor(canvas) {
                this.canvas = canvas;
                this.biomeManager = new BiomeManager(canvas.width, canvas.height, 30); // Updated tileSize parameter
                
                // Get the world size
                const worldSize = this.biomeManager.getWorldSize();
                this.worldWidth = worldSize.width;
                this.worldHeight = worldSize.height;
                
                // Initialize camera position to center of the world
                this.cameraX = this.worldWidth / 2 - canvas.width / 2;
                this.cameraY = this.worldHeight / 2 - canvas.height / 2;
                this.normalizedCameraX = this.cameraX;
                this.normalizedCameraY = this.cameraY;
            }
            
            // Update camera to follow the blob
            updateCamera(blob, canvas) {
                // Calculate the center position for the camera
                let targetX = blob.x - canvas.width / 2;
                let targetY = blob.y - canvas.height / 2;
                
                // Handle camera position for wrapped world
                // Instead of limiting to boundaries, we wrap around
                this.cameraX = targetX;
                this.cameraY = targetY;
                
                // Normalize camera position to ensure we're drawing biomes correctly
                this.normalizedCameraX = ((this.cameraX % this.worldWidth) + this.worldWidth) % this.worldWidth;
                this.normalizedCameraY = ((this.cameraY % this.worldHeight) + this.worldHeight) % this.worldHeight;
            }

            draw(ctx) {
                // Draw biomes with camera offset
                this.biomeManager.draw(ctx, this.normalizedCameraX, this.normalizedCameraY, this.canvas.width, this.canvas.height);
                
                // For a wrapped world, we need to draw the edges that wrap around
                // This ensures seamless transitions when moving across the world boundaries
                this.drawWrappedEdges(ctx);
                
                // Draw world border (as a reference, but not as a barrier)
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.strokeRect(-this.normalizedCameraX, -this.normalizedCameraY, this.worldWidth, this.worldHeight);
            }
            
            drawWrappedEdges(ctx) {
                const viewportWidth = this.canvas.width;
                const viewportHeight = this.canvas.height;
                
                // Only draw wrapped edges if we're near the world boundaries
                const nearRightEdge = this.normalizedCameraX + viewportWidth > this.worldWidth;
                const nearBottomEdge = this.normalizedCameraY + viewportHeight > this.worldHeight;
                
                if (nearRightEdge) {
                    // Draw the left side of the world on the right edge of the viewport
                    this.biomeManager.draw(
                        ctx, 
                        this.normalizedCameraX - this.worldWidth, 
                        this.normalizedCameraY,
                        viewportWidth,
                        viewportHeight
                    );
                }
                
                if (nearBottomEdge) {
                    // Draw the top of the world on the bottom edge of the viewport
                    this.biomeManager.draw(
                        ctx,
                        this.normalizedCameraX,
                        this.normalizedCameraY - this.worldHeight,
                        viewportWidth,
                        viewportHeight
                    );
                }
                
                if (nearRightEdge && nearBottomEdge) {
                    // Draw the top-left corner of the world on the bottom-right corner of the viewport
                    this.biomeManager.draw(
                        ctx,
                        this.normalizedCameraX - this.worldWidth,
                        this.normalizedCameraY - this.worldHeight,
                        viewportWidth,
                        viewportHeight
                    );
                }
            }
            
            getBiomeAt(x, y) {
                // Wrap coordinates for sphere-like world
                const wrappedX = ((x % this.worldWidth) + this.worldWidth) % this.worldWidth;
                const wrappedY = ((y % this.worldHeight) + this.worldHeight) % this.worldHeight;
                return this.biomeManager.getBiomeAt(wrappedX, wrappedY);
            }
            
            // Convert screen coordinates to world coordinates
            screenToWorld(screenX, screenY) {
                return {
                    x: screenX + this.cameraX,
                    y: screenY + this.cameraY
                };
            }
            
            // Convert world coordinates to screen coordinates
            worldToScreen(worldX, worldY) {
                // Calculate the shortest distance considering wrap-around
                const dx = (worldX - this.cameraX + this.worldWidth / 2) % this.worldWidth - this.worldWidth / 2;
                const dy = (worldY - this.cameraY + this.worldHeight / 2) % this.worldHeight - this.worldHeight / 2;
                
                return {
                    x: dx + this.canvas.width / 2,
                    y: dy + this.canvas.height / 2
                };
            }
        }

        // Stats Display class
        class StatsDisplay {
            constructor(canvas) {
                this.canvas = canvas;
                // Stats panel dimensions - reduced width for more compact display
                this.panelWidth = 190; // Reduced from 230 to 190
                this.panelHeight = 250; // Keep same height
                this.barWidth = 70; // Reduced from 100 to 70 for narrower bars
            }
            
            draw(ctx, stats, currentBiome, traits) {
                const { hunger, energy, temperature, mood, health, experience, evolutionLevel, foodCounter } = stats;
                
                // Background for stats panel
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(10, 10, this.panelWidth, this.panelHeight);
                
                // Set text style
                ctx.font = '12px Arial'; // Changed from 16px to 12px to match controls panel
                ctx.fillStyle = 'white';
                
                // Draw stats headings and values
                ctx.fillText('Blob Stats:', 20, 30);
                
                // Hunger bar
                this.drawStatBar(ctx, 'Hunger', hunger, 20, 45, this.getColorForStat(hunger, true));
                
                // Energy bar
                this.drawStatBar(ctx, 'Energy', energy, 20, 65, this.getColorForStat(energy, true));
                
                // Health bar
                this.drawStatBar(ctx, 'Health', health, 20, 85, this.getColorForStat(health, true));
                
                // Temperature (now in Celsius)
                this.drawTemperatureBar(ctx, temperature, 20, 105);
                
                // Mood bar
                this.drawStatBar(ctx, 'Mood', mood, 20, 125, this.getColorForStat(mood, true));
                
                // Experience bar
                this.drawExperienceBar(ctx, stats, 20, 145);
                
                // Evolution level
                ctx.fillText(`Evolution: Level ${evolutionLevel}`, 20, 165);
                
                // Blob's current biome - renamed to clarify it's for the blob
                if (currentBiome) {
                    ctx.fillText(`Blob Biome: ${currentBiome.type}`, 20, 185);
                }
                
                // Food counter
                ctx.fillText(`Food: Evolve On Eat`, 20, 205);
                
                // Traits display
                if (traits) {
                    const activeTraits = [];
                    if (traits.spikes) activeTraits.push('Spikes');
                    if (traits.fins) activeTraits.push('Fins');
                    if (traits.furCoat) activeTraits.push('Fur');
                    if (traits.camouflage) activeTraits.push('Camo');
                    if (traits.glowingSpots) activeTraits.push('Glow');
                    
                    const traitsText = activeTraits.length > 0 
                        ? `Traits: ${activeTraits.join(', ')}` 
                        : 'Traits: None';
                    
                    ctx.fillText(traitsText, 20, 225);
                }
                
                // Dog's current biome - new addition
                if (window.gameInstance && window.gameInstance.person && window.gameInstance.world) {
                    const dogBiome = window.gameInstance.world.getBiomeAt(
                        window.gameInstance.person.x, 
                        window.gameInstance.person.y
                    );
                    if (dogBiome) {
                        ctx.fillText(`Dog Biome: ${dogBiome.type}`, 20, 245);
                    }
                }
                
                // Reset text color and font
                ctx.fillStyle = 'white';
                // Used 12px font throughout this panel to match controls panel
            }
            
            drawStatBar(ctx, label, value, x, y, color) {
                // Draw label
                ctx.fillStyle = 'white';
                ctx.fillText(label + ':', x, y);
                
                // Draw background bar
                ctx.fillStyle = '#444';
                ctx.fillRect(x + 70, y - 12, this.barWidth, 15);
                
                // Draw value bar
                ctx.fillStyle = color;
                // Make sure value doesn't exceed bar width
                const barValue = Math.min(value, this.barWidth);
                ctx.fillRect(x + 70, y - 12, barValue, 15);
                
                // Draw value text - adjusted position for narrower panel
                ctx.fillStyle = 'white';
                ctx.fillText(Math.round(value) + '%', x + this.barWidth + 75, y);
            }
            
            drawTemperatureBar(ctx, temperature, x, y) {
                // Draw label
                ctx.fillStyle = 'white';
                ctx.fillText('Temp:', x, y);
                
                // Draw background bar
                ctx.fillStyle = '#444';
                ctx.fillRect(x + 70, y - 12, this.barWidth, 15);
                
                // Map temperature from Celsius (-10 to 45) to bar width (0 to barWidth)
                const minTemp = -10;
                const maxTemp = 45;
                const tempRange = maxTemp - minTemp;
                const normalizedTemp = (temperature - minTemp) / tempRange;
                const barValue = normalizedTemp * this.barWidth;
                
                // Draw value bar
                ctx.fillStyle = this.getTemperatureColor(temperature);
                ctx.fillRect(x + 70, y - 12, barValue, 15);
                
                // Draw value text with °C
                ctx.fillStyle = 'white';
                ctx.fillText(`${Math.round(temperature)}°C`, x + this.barWidth + 75, y);
            }
            
            drawExperienceBar(ctx, stats, x, y) {
                const progressPercent = stats.getExperienceProgress();
                
                // Draw label
                ctx.fillStyle = 'white';
                ctx.fillText('XP:', x, y);
                
                // Draw background bar
                ctx.fillStyle = '#444';
                ctx.fillRect(x + 70, y - 12, this.barWidth, 15);
                
                // Draw progress bar
                ctx.fillStyle = '#9C27B0'; // Purple for experience
                const barValue = (progressPercent / 100) * this.barWidth;
                ctx.fillRect(x + 70, y - 12, barValue, 15);
                
                // Draw experience text
                ctx.fillStyle = 'white';
                ctx.fillText(`${Math.round(stats.experience)}`, x + this.barWidth + 75, y);
            }
            
            getColorForStat(value, highIsGood = true) {
                if (highIsGood) {
                    if (value > 75) return '#4CAF50'; // Green for good
                    if (value > 50) return '#FFC107'; // Yellow for medium
                    if (value > 25) return '#FF9800'; // Orange for low
                    return '#F44336'; // Red for critical
                } else {
                    if (value < 25) return '#4CAF50'; // Green for good (low value)
                    if (value < 50) return '#FFC107'; // Yellow for medium
                    if (value < 75) return '#FF9800'; // Orange for high
                    return '#F44336'; // Red for critical (high value)
                }
            }
            
            getTemperatureColor(temperature) {
                if (temperature < 0) return '#2196F3';      // Blue for freezing
                if (temperature < 10) return '#90CAF9';     // Light blue for cold
                if (temperature < 20) return '#4CAF50';     // Green for cool
                if (temperature < 30) return '#FFC107';     // Yellow for warm
                return '#F44336';                           // Red for hot
            }
        }

        // Person class to interact with the blob
        class Person {
            constructor(x, y, world) {  // Add world parameter
                this.x = x;
                this.y = y;
                this.world = world;     // Store world reference
                this.width = 31;       // Increased by 40% from 22 to 31
                this.height = 63;      // Increased by 40% from 45 to 63
                this.color = '#8B4513'; // Brown for dog fur (changed from orange-red)
                this.outlineColor = '#5D4037'; // Darker brown outline (changed from purple)
                this.speed = 4;
                this.keys = {
                    KeyW: false,
                    KeyA: false,
                    KeyS: false,
                    KeyD: false
                };
                this.direction = 'down'; // facing direction: up, down, left, right
                
                // Animation properties
                this.walkCycle = 0;
                this.isMoving = false;
                this.lastMoveTime = Date.now();
                this.tailWagAngle = 0; // New property for tail wagging
                
                // Initialize inventory system
                this.inventory = new Inventory();
                this.inventory.maxSlots = 20; // Give person more inventory slots
                this.activeFood = null;
                this.isFeeding = false;
                this.foodCircle = {
                    x: 0, 
                    y: 0, 
                    radius: 15, // Increased from 10 to 15 for better visibility
                    color: '#FFA500'
                };
                
                // Initialize messages array
                this.messages = [];
                
                // Store canvas reference
                this.canvas = document.getElementById('gameCanvas');
                
                this.setupControls();
                
                // Setup mouse click handler for inventory
                window.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const canvasX = e.clientX - rect.left;
                    const canvasY = e.clientY - rect.top;
                    
                    // Handle inventory click
                    if (this.inventory.visible) {
                        // Use document.getElementById instead of this.canvas which might be undefined
                        const canvas = document.getElementById('gameCanvas');
                        this.inventory.handleClick(canvasX, canvasY, canvas.width, canvas.height);
                        // activeFood is now updated via the inventorySelectionChanged event
                    }
                });
                
                // Listen for inventory selection changes
                window.addEventListener('inventorySelectionChanged', (e) => {
                    console.log('Inventory selection changed:', e.detail);
                    // Update active food based on selected item
                    const selectedItem = this.inventory.selectedItem ? 
                                        this.inventory.items[this.inventory.selectedItem] : null;
                    
                    if (selectedItem && selectedItem.type === 'resource') {
                        this.activeFood = {
                            type: selectedItem.name,
                            nutrientValue: 10,
                            energyValue: 5
                        };
                        
                        // Update food circle color based on food type
                        switch(selectedItem.name.toLowerCase()) {
                            case 'berries': this.foodCircle.color = '#CC0066'; break;
                            case 'nuts': this.foodCircle.color = '#8B4513'; break;
                            case 'cactus': this.foodCircle.color = '#7FFF00'; break;
                            case 'fish': this.foodCircle.color = '#4682B4'; break;
                            case 'minerals': this.foodCircle.color = '#B8B8B8'; break;
                            default: this.foodCircle.color = '#FFFFFF';
                        }
                        console.log('Updated active food:', this.activeFood);
                        this.showMessage(`Selected ${selectedItem.name} for feeding`);
                    } else {
                        // Clear active food if no valid item is selected
                        this.activeFood = null;
                        console.log('No valid food item selected');
                        if (this.isFeeding) {
                            this.isFeeding = false;
                            this.showMessage('Feeding stopped');
                        }
                    }
                });
            }
            
            setupControls() {
                window.addEventListener('keydown', (e) => {
                    if (this.keys.hasOwnProperty(e.code)) {
                        this.keys[e.code] = true;
                    }
                    
                    // Press Q to feed blob with currently selected food
                    if (e.code === 'KeyQ') {
                        if (this.inventory.selectedItem && this.inventory.items[this.inventory.selectedItem]) {
                            // Reset feeding state first to ensure clean start
                            this.isFeeding = false;
                            setTimeout(() => {
                                // Set feeding state after a brief delay
                                this.isFeeding = true;
                                const selectedItem = this.inventory.items[this.inventory.selectedItem];
                                console.log('Feeding with selected item:', selectedItem);
                                
                                this.activeFood = {
                                    type: selectedItem.name,
                                    nutrientValue: 10,
                                    energyValue: 5
                                };
                                
                                // Update food circle color based on food type
                                switch(selectedItem.name.toLowerCase()) {
                                    case 'berries': this.foodCircle.color = '#CC0066'; break;
                                    case 'nuts': this.foodCircle.color = '#8B4513'; break;
                                    case 'cactus': this.foodCircle.color = '#7FFF00'; break;
                                    case 'fish': this.foodCircle.color = '#4682B4'; break;
                                    case 'minerals': this.foodCircle.color = '#B8B8B8'; break;
                                    default: this.foodCircle.color = '#FFFFFF';
                                }
                                
                                // Ensure food circle is visible - force a minimum radius
                                this.foodCircle.radius = Math.max(15, this.foodCircle.radius);
                                
                                // Get blob for reference size if available
                                const blob = window.gameInstance ? window.gameInstance.blob : null;
                                
                                // Calculate appropriate distance based on dog and blob size
                                // Use a fixed multiplier of the dog size plus a margin
                                const dogSizeMultiplier = 1.5;
                                const blobRadiusAdjustment = blob ? blob.radius * 0.8 : 0;
                                
                                // Position the food circle further away to account for larger dog and blob sizes
                                const foodCircleDistance = this.foodCircle.radius * 2 + 20 + blobRadiusAdjustment;
                                
                                // Position the food circle
                                switch(this.direction) {
                                    case 'up':
                                        this.foodCircle.x = this.x;
                                        this.foodCircle.y = this.y - this.height * dogSizeMultiplier - foodCircleDistance;
                                        break;
                                    case 'down':
                                        this.foodCircle.x = this.x;
                                        this.foodCircle.y = this.y + this.height * dogSizeMultiplier + foodCircleDistance;
                                        break;
                                    case 'left':
                                        this.foodCircle.x = this.x - this.width * dogSizeMultiplier - foodCircleDistance;
                                        this.foodCircle.y = this.y;
                                        break;
                                    case 'right':
                                        this.foodCircle.x = this.x + this.width * dogSizeMultiplier + foodCircleDistance;
                                        this.foodCircle.y = this.y;
                                        break;
                                }
                                
                                console.log('Food circle positioned at:', 
                                          {x: this.foodCircle.x, y: this.foodCircle.y}, 
                                          'Direction:', this.direction,
                                          'Blob radius:', blob ? blob.radius : 'unknown',
                                          'isFeeding state:', this.isFeeding);
                            }, 50);
                        } else {
                            console.log('No food selected for feeding');
                            this.showMessage('Select food from inventory first!');
                        }
                    }
                });

                window.addEventListener('keyup', (e) => {
                    if (this.keys.hasOwnProperty(e.code)) {
                        this.keys[e.code] = false;
                    }
                    
                    if (e.code === 'KeyQ') {
                        this.isFeeding = false;
                    }
                });
            }
            
            // Check if person is collecting food
            isCollectingFood(food) {
                const dx = this.x - food.x;
                const dy = this.y - food.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < (this.width/2 + food.radius);
            }
            
            update(worldWidth, worldHeight) {
                // Calculate movement based on keys
                let dx = 0;
                let dy = 0;
                
                if (this.keys.KeyW) {
                    dy -= this.speed;
                    this.direction = 'up';
                }
                if (this.keys.KeyS) {
                    dy += this.speed;
                    this.direction = 'down';
                }
                if (this.keys.KeyA) {
                    dx -= this.speed;
                    this.direction = 'left';
                }
                if (this.keys.KeyD) {
                    dx += this.speed;
                    this.direction = 'right';
                }
                
                // Get the current biome the person is in
                let currentBiome = null;
                if (this.world && this.world.biomeManager) {
                    currentBiome = this.world.biomeManager.getBiomeAt(this.x, this.y);
                }
                
                // Apply biome-specific movement modifiers
                let biomeFactor = 1.0;
                if (currentBiome) {
                    // Apply water slowdown
                    if (currentBiome.type === 'Water') {
                        biomeFactor = 0.5; // 50% slower in water (changed from 0.7)
                    }
                    // Apply desert slowdown
                    else if (currentBiome.type === 'Desert') {
                        biomeFactor = 0.85; // 15% slower in desert
                    }
                    // Apply mountain slowdown
                    else if (currentBiome.type === 'Mountains') {
                        biomeFactor = 0.8; // 20% slower in mountains
                    }
                }
                
                // Apply speed modifiers
                dx *= biomeFactor;
                dy *= biomeFactor;
                
                // Move the person
                this.x += dx;
                this.y += dy;
                
                // World wrap-around (sphere-like)
                if (this.x < 0) this.x = worldWidth;
                if (this.x > worldWidth) this.x = 0;
                if (this.y < 0) this.y = worldHeight;
                if (this.y > worldHeight) this.y = 0;
                
                // Update food circle position if feeding
                if (this.isFeeding) {
                    // Ensure food circle is visible - force a minimum radius
                    this.foodCircle.radius = Math.max(15, this.foodCircle.radius);
                    
                    // Get blob for reference size if available
                    const blob = window.gameInstance ? window.gameInstance.blob : null;
                    
                    // Only calculate this if we have a blob reference
                    if (blob) {
                        // Calculate appropriate distance based on dog and blob size
                        // Use a fixed multiplier of the dog size plus a margin
                        const dogSizeMultiplier = 1.5;
                        const blobRadiusAdjustment = blob.radius * 0.8;
                        
                        // Position the food circle further away to account for larger dog and blob sizes
                        const foodCircleDistance = this.foodCircle.radius * 2 + 20 + blobRadiusAdjustment;
                        
                        switch(this.direction) {
                            case 'up':
                                this.foodCircle.x = this.x;
                                this.foodCircle.y = this.y - this.height * dogSizeMultiplier - foodCircleDistance;
                                break;
                            case 'down':
                                this.foodCircle.x = this.x;
                                this.foodCircle.y = this.y + this.height * dogSizeMultiplier + foodCircleDistance;
                                break;
                            case 'left':
                                this.foodCircle.x = this.x - this.width * dogSizeMultiplier - foodCircleDistance;
                                this.foodCircle.y = this.y;
                                break;
                            case 'right':
                                this.foodCircle.x = this.x + this.width * dogSizeMultiplier + foodCircleDistance;
                                this.foodCircle.y = this.y;
                                break;
                        }
                    }
                }
            }
            
            draw(ctx, cameraX, cameraY) {
                // Calculate screen position
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Only draw if on screen
                if (screenX + this.width < 0 || screenX > ctx.canvas.width || 
                    screenY + this.height < 0 || screenY > ctx.canvas.height) {
                    return;
                }
                
                // Animation logic - update walk cycle when moving
                const now = Date.now();
                this.isMoving = this.keys.KeyW || this.keys.KeyA || this.keys.KeyS || this.keys.KeyD;
                
                if (this.isMoving) {
                    // Advance walk cycle every 150ms while moving
                    if (now - this.lastMoveTime > 150) {
                        this.walkCycle = (this.walkCycle + 1) % 4;
                        this.lastMoveTime = now;
                    }
                } else {
                    // Reset walk cycle when standing still
                    this.walkCycle = 0;
                }
                
                // Update tail wag animation
                this.tailWagAngle = Math.sin(now / 200) * 0.5;
                
                // Draw shadow
                ctx.beginPath();
                ctx.ellipse(screenX, screenY + this.height/2 - 5, this.width/2, this.width/4, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fill();
                
                // Draw dog body based on direction
                this.drawDogBody(ctx, screenX, screenY);
                
                // Draw legs
                this.drawLegs(ctx, screenX, screenY);
                
                // Draw tail
                this.drawTail(ctx, screenX, screenY);
                
                // Draw dog head
                this.drawDogHead(ctx, screenX, screenY);
                
                // Draw food circle if feeding
                if (this.isFeeding) {
                    // Double check that we really should be feeding
                    console.log('Drawing food circle - isFeeding state:', this.isFeeding);
                    
                    const foodScreenX = this.foodCircle.x - cameraX;
                    const foodScreenY = this.foodCircle.y - cameraY;
                    
                    // Debug log food circle info
                    console.log('Drawing food circle:', {
                        x: foodScreenX, 
                        y: foodScreenY, 
                        radius: this.foodCircle.radius,
                        color: this.foodCircle.color
                    });
                    
                    // Ensure the food circle is big enough to be visible
                    const displayRadius = Math.max(this.foodCircle.radius, 15);
                    
                    // Draw main food circle with a strong outline for better visibility
                    ctx.beginPath();
                    ctx.arc(foodScreenX, foodScreenY, displayRadius, 0, Math.PI * 2);
                    ctx.fillStyle = this.foodCircle.color;
                    ctx.fill();
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Add a glow effect for better visibility
                    const gradient = ctx.createRadialGradient(
                        foodScreenX, foodScreenY, displayRadius * 0.5,
                        foodScreenX, foodScreenY, displayRadius * 1.5
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(foodScreenX, foodScreenY, displayRadius * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add a little shine/highlight
                    ctx.beginPath();
                    ctx.arc(
                        foodScreenX - displayRadius/3, 
                        foodScreenY - displayRadius/3, 
                        displayRadius/3, 
                        0, Math.PI * 2
                    );
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.fill();
                }
                
                // Update and draw messages
                this.updateMessages();
                this.drawMessages(ctx, cameraX, cameraY);

                // Draw inventory if visible
                if (this.inventory.visible) {
                    this.inventory.draw(ctx, ctx.canvas.width, ctx.canvas.height);
                }
            }
            
            drawDogBody(ctx, x, y) {
                // Draw main body - more athletic dog shape with better proportions
                ctx.beginPath();
                ctx.ellipse(x, y, this.width * 0.9, this.height * 0.25, 0, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                // Add some muscle definition/shading to make the dog look more athletic
                const gradientBody = ctx.createLinearGradient(x - this.width * 0.9, y, x + this.width * 0.9, y);
                gradientBody.addColorStop(0, this.color);
                gradientBody.addColorStop(0.5, '#A0522D'); // Slightly darker in middle for definition
                gradientBody.addColorStop(1, this.color);
                ctx.fillStyle = gradientBody;
                ctx.beginPath();
                ctx.ellipse(x, y, this.width * 0.85, this.height * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = this.outlineColor;
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // Draw stylish collar - now a leather collar with studs
                ctx.beginPath();
                ctx.moveTo(x - this.width * 0.35, y - this.height * 0.12);
                ctx.lineTo(x + this.width * 0.35, y - this.height * 0.12);
                ctx.lineWidth = 3.5;
                ctx.strokeStyle = '#5D4037'; // Darker brown leather color
                ctx.stroke();
                
                // Add collar studs
                for (let i = 0; i <= 3; i++) {
                    const studX = x - this.width * 0.3 + (this.width * 0.6 * (i/3));
                    ctx.beginPath();
                    ctx.arc(studX, y - this.height * 0.12, 2, 0, Math.PI * 2);
                    ctx.fillStyle = '#CDDC39'; // Metallic lime color for studs
                    ctx.fill();
                    ctx.strokeStyle = '#AFB42B';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
                
                // Draw collar tag - larger, more detailed
                ctx.beginPath();
                ctx.arc(x, y - this.height * 0.12, 4, 0, Math.PI * 2);
                const gradientTag = ctx.createRadialGradient(x, y - this.height * 0.12, 0, x, y - this.height * 0.12, 4);
                gradientTag.addColorStop(0, '#FFF176'); // Lighter gold in center
                gradientTag.addColorStop(1, '#FFC107'); // Darker gold at edges
                ctx.fillStyle = gradientTag;
                ctx.fill();
                ctx.strokeStyle = '#FFA000';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Add a small bone shape to the tag
                ctx.beginPath();
                ctx.ellipse(x - 1, y - this.height * 0.12 - 1, 1, 0.7, 0, 0, Math.PI * 2);
                ctx.ellipse(x + 1, y - this.height * 0.12 - 1, 1, 0.7, 0, 0, Math.PI * 2);
                ctx.ellipse(x - 1, y - this.height * 0.12 + 1, 1, 0.7, 0, 0, Math.PI * 2);
                ctx.ellipse(x + 1, y - this.height * 0.12 + 1, 1, 0.7, 0, 0, Math.PI * 2);
                ctx.fillStyle = '#795548';
                ctx.fill();
            }
            
            drawTail(ctx, x, y) {
                ctx.save();
                
                // Position at the back of the dog based on direction
                let tailX = x;
                let tailY = y;
                
                switch(this.direction) {
                    case 'left':
                        tailX = x + this.width * 0.7;
                        tailY = y - this.height * 0.05;
                        break;
                    case 'right':
                        tailX = x - this.width * 0.7;
                        tailY = y - this.height * 0.05;
                        break;
                    case 'up':
                        tailX = x;
                        tailY = y + this.height * 0.25;
                        break;
                    case 'down':
                        tailX = x;
                        tailY = y - this.height * 0.25;
                        break;
                }
                
                // Increase tail wag amplitude for more expressive movement
                const wagAngle = this.tailWagAngle * 1.5;
                
                // Rotate around the base of the tail
                ctx.translate(tailX, tailY);
                ctx.rotate(wagAngle);
                
                // Draw a cooler, fluffier dog tail
                ctx.beginPath();
                ctx.moveTo(0, 0);
                
                // Create an S-shaped curve for a more natural tail
                ctx.bezierCurveTo(
                    8, -12,
                    20, -18,
                    25, -8
                );
                
                // Add volume to the tail with a second curve
                ctx.lineTo(25, -6);
                ctx.bezierCurveTo(
                    22, -15,
                    10, -5,
                    0, 0
                );
                ctx.closePath();
                
                // Add a gradient to the tail for more dimension
                const tailGradient = ctx.createLinearGradient(0, 0, 25, -8);
                tailGradient.addColorStop(0, this.color); // Base color at tail root
                tailGradient.addColorStop(1, '#6D4C41'); // Slightly darker at tip
                ctx.fillStyle = tailGradient;
                ctx.fill();
                
                ctx.strokeStyle = this.outlineColor;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Add some "fur" details to the tail
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const furX = 5 + (i * 4);
                    const furY = -5 - (i * 1.5);
                    const furLength = 2 + Math.random() * 3;
                    ctx.moveTo(furX, furY);
                    ctx.lineTo(furX + 1, furY - furLength);
                }
                ctx.strokeStyle = this.outlineColor;
                ctx.lineWidth = 0.5;
                ctx.stroke();
                
                ctx.restore();
            }
            
            drawLegs(ctx, x, y) {
                const walkOffset = Math.sin(this.walkCycle * Math.PI/2) * 2;
                const legHeight = this.height/3.5; // Longer, more athletic legs
                const legWidth = 5; // Slightly thinner
                
                // Use gradient for more dynamic coloring
                const legGradient = ctx.createLinearGradient(0, y, 0, y + legHeight);
                legGradient.addColorStop(0, this.color);
                legGradient.addColorStop(1, '#5D4037'); // Darker near paws
                
                // Position legs with better spacing and create a walking animation
                const drawLeg = (legX, frontLeg) => {
                    const offset = this.isMoving ? (frontLeg ? walkOffset : -walkOffset) : 0;
                    
                    // Leg with subtle curve
                    ctx.beginPath();
                    ctx.moveTo(legX, y);
                    ctx.quadraticCurveTo(
                        legX + (frontLeg ? -2 : 2), 
                        y + legHeight/2, 
                        legX + offset, 
                        y + legHeight
                    );
                    ctx.lineTo(legX + offset + legWidth, y + legHeight);
                    ctx.quadraticCurveTo(
                        legX + legWidth + (frontLeg ? -2 : 2), 
                        y + legHeight/2, 
                        legX + legWidth, 
                        y
                    );
                    ctx.closePath();
                    
                    ctx.fillStyle = legGradient;
                    ctx.fill();
                    ctx.strokeStyle = this.outlineColor;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Draw paw
                    ctx.fillStyle = '#3E2723'; // Very dark brown for paws
                    ctx.beginPath();
                    ctx.ellipse(
                        legX + offset + legWidth/2, 
                        y + legHeight + 2, 
                        legWidth * 0.9, 
                        legHeight * 0.1, 
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();
                    
                    // Draw toe details
                    ctx.beginPath();
                    for (let i = 0; i < 3; i++) {
                        const toeX = legX + offset + legWidth/2 - legWidth*0.4 + (i * legWidth*0.4);
                        ctx.moveTo(toeX, y + legHeight + 1);
                        ctx.lineTo(toeX, y + legHeight + 3);
                    }
                    ctx.strokeStyle = '#1B0000';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                };
                
                // Draw legs in the correct order based on direction
                if (this.direction === 'left') {
                    // For left-facing, draw right legs (far side) first
                    drawLeg(x + this.width * 0.4, false); // Back right
                    drawLeg(x - this.width * 0.1, true);  // Front right
                    drawLeg(x + this.width * 0.1, false); // Back left
                    drawLeg(x - this.width * 0.4, true);  // Front left
                } else {
                    // For other directions, draw all legs
                    drawLeg(x - this.width * 0.4, true);  // Front left
                    drawLeg(x - this.width * 0.1, true);  // Front right
                    drawLeg(x + this.width * 0.1, false); // Back left
                    drawLeg(x + this.width * 0.4, false); // Back right
                }
            }
            
            drawDogHead(ctx, x, y) {
                let headX = x;
                let headY = y - this.height * 0.25;
                
                // Position head based on direction
                switch(this.direction) {
                    case 'left':
                        headX = x - this.width * 0.6;
                        break;
                    case 'right':
                        headX = x + this.width * 0.6;
                        break;
                    case 'up':
                        headY = y - this.height * 0.3;
                        break;
                    case 'down':
                        headY = y - this.height * 0.2;
                        break;
                }
                
                // Draw head - cooler dog-shaped head with better shading
                ctx.beginPath();
                ctx.arc(headX, headY, this.width * 0.28, 0, Math.PI * 2);
                
                // Create gradient for more dimension
                const headGradient = ctx.createRadialGradient(
                    headX - this.width * 0.05, 
                    headY - this.width * 0.05, 
                    this.width * 0.05,
                    headX, 
                    headY, 
                    this.width * 0.28
                );
                headGradient.addColorStop(0, '#A1887F'); // Lighter highlight
                headGradient.addColorStop(0.7, this.color);
                headGradient.addColorStop(1, '#6D4C41'); // Darker edge
                
                ctx.fillStyle = headGradient;
                ctx.fill();
                ctx.strokeStyle = this.outlineColor;
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // Draw ears first (so they go behind the eyes)
                this.drawEars(ctx, headX, headY);
                
                // Draw snout
                this.drawSnout(ctx, headX, headY);
                
                // Draw face (eyes) on top
                this.drawFace(ctx, headX, headY);
                
                // If feeding, show food type above dog
                if (this.activeFood) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${this.activeFood.type}`, headX, headY - this.width * 0.7);
                }
            }
            
            drawFace(ctx, x, y) {
                // Draw eyes - make them more expressive
                const eyeOffsetX = this.width * 0.12;
                const eyeOffsetY = -this.width * 0.02; // Moved slightly up
                const eyeSize = this.width * 0.06;
                
                // Add shading around eyes for definition
                ctx.fillStyle = '#5D4037';
                ctx.beginPath();
                ctx.ellipse(x - eyeOffsetX, y + eyeOffsetY, eyeSize * 1.2, eyeSize * 1.1, 0, 0, Math.PI * 2);
                ctx.ellipse(x + eyeOffsetX, y + eyeOffsetY, eyeSize * 1.2, eyeSize * 1.1, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Left eye
                ctx.beginPath();
                ctx.arc(x - eyeOffsetX, y + eyeOffsetY, eyeSize, 0, Math.PI * 2);
                
                // Add eye shine gradient
                const eyeGradient = ctx.createRadialGradient(
                    x - eyeOffsetX, y + eyeOffsetY, 0,
                    x - eyeOffsetX, y + eyeOffsetY, eyeSize
                );
                eyeGradient.addColorStop(0, 'white');
                eyeGradient.addColorStop(1, '#E0E0E0');
                
                ctx.fillStyle = eyeGradient;
                ctx.fill();
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 0.5;
                ctx.stroke();
                
                // Left pupil with movement based on direction
                let pupilOffsetX = 0;
                if (this.direction === 'left') pupilOffsetX = -eyeSize * 0.3;
                if (this.direction === 'right') pupilOffsetX = eyeSize * 0.3;
                
                ctx.beginPath();
                ctx.arc(x - eyeOffsetX + pupilOffsetX, y + eyeOffsetY, eyeSize * 0.5, 0, Math.PI * 2);
                ctx.fillStyle = '#000000';
                ctx.fill();
                
                // Pupil highlight for life-like appearance
                ctx.beginPath();
                ctx.arc(x - eyeOffsetX + pupilOffsetX - eyeSize * 0.15, y + eyeOffsetY - eyeSize * 0.15, eyeSize * 0.15, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fill();
                
                // Right eye - same technique
                ctx.beginPath();
                ctx.arc(x + eyeOffsetX, y + eyeOffsetY, eyeSize, 0, Math.PI * 2);
                ctx.fillStyle = eyeGradient;
                ctx.fill();
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 0.5;
                ctx.stroke();
                
                // Right pupil
                ctx.beginPath();
                ctx.arc(x + eyeOffsetX + pupilOffsetX, y + eyeOffsetY, eyeSize * 0.5, 0, Math.PI * 2);
                ctx.fillStyle = '#000000';
                ctx.fill();
                
                // Pupil highlight
                ctx.beginPath();
                ctx.arc(x + eyeOffsetX + pupilOffsetX - eyeSize * 0.15, y + eyeOffsetY - eyeSize * 0.15, eyeSize * 0.15, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fill();
                
                // Add eyebrows for more expression
                const eyebrowAngle = this.isMoving ? Math.PI * 0.1 : 0; // Slight angle when moving
                
                ctx.beginPath();
                ctx.moveTo(x - eyeOffsetX - eyeSize, y + eyeOffsetY - eyeSize - 1);
                ctx.lineTo(x - eyeOffsetX + eyeSize, y + eyeOffsetY - eyeSize - 1 + eyebrowAngle);
                ctx.moveTo(x + eyeOffsetX - eyeSize, y + eyeOffsetY - eyeSize - 1 + eyebrowAngle);
                ctx.lineTo(x + eyeOffsetX + eyeSize, y + eyeOffsetY - eyeSize - 1);
                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
            
            drawEars(ctx, x, y) {
                // Draw cooler, floppier ears with better shape and shading
                
                // Left ear - use bezier curves for a natural floppy shape
                ctx.beginPath();
                ctx.moveTo(x - this.width * 0.15, y - this.width * 0.12);
                
                // Create ear shape with bezier curves for natural folds
                ctx.bezierCurveTo(
                    x - this.width * 0.25, y - this.width * 0.3, // Control point 1
                    x - this.width * 0.45, y - this.width * 0.1, // Control point 2
                    x - this.width * 0.35, y + this.width * 0.15  // End point
                );
                
                ctx.bezierCurveTo(
                    x - this.width * 0.3, y + this.width * 0.05, // Control point 1
                    x - this.width * 0.2, y, // Control point 2
                    x - this.width * 0.15, y - this.width * 0.05  // End point (connecting back)
                );
                
                ctx.closePath();
                
                // Gradient for ear shading
                const earGradient = ctx.createLinearGradient(
                    x - this.width * 0.15, y - this.width * 0.12,
                    x - this.width * 0.35, y + this.width * 0.15
                );
                earGradient.addColorStop(0, this.color);
                earGradient.addColorStop(1, '#5D4037'); // Darker at the tips
                
                ctx.fillStyle = earGradient;
                ctx.fill();
                ctx.strokeStyle = this.outlineColor;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Right ear - mirror of left ear
                ctx.beginPath();
                ctx.moveTo(x + this.width * 0.15, y - this.width * 0.12);
                
                ctx.bezierCurveTo(
                    x + this.width * 0.25, y - this.width * 0.3,
                    x + this.width * 0.45, y - this.width * 0.1,
                    x + this.width * 0.35, y + this.width * 0.15
                );
                
                ctx.bezierCurveTo(
                    x + this.width * 0.3, y + this.width * 0.05,
                    x + this.width * 0.2, y,
                    x + this.width * 0.15, y - this.width * 0.05
                );
                
                ctx.closePath();
                
                // Gradient for right ear
                const rightEarGradient = ctx.createLinearGradient(
                    x + this.width * 0.15, y - this.width * 0.12,
                    x + this.width * 0.35, y + this.width * 0.15
                );
                rightEarGradient.addColorStop(0, this.color);
                rightEarGradient.addColorStop(1, '#5D4037');
                
                ctx.fillStyle = rightEarGradient;
                ctx.fill();
                ctx.strokeStyle = this.outlineColor;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Add ear detail lines for texture
                ctx.beginPath();
                
                // Left ear details
                ctx.moveTo(x - this.width * 0.2, y - this.width * 0.05);
                ctx.quadraticCurveTo(
                    x - this.width * 0.3, y,
                    x - this.width * 0.25, y + this.width * 0.1
                );
                
                // Right ear details
                ctx.moveTo(x + this.width * 0.2, y - this.width * 0.05);
                ctx.quadraticCurveTo(
                    x + this.width * 0.3, y,
                    x + this.width * 0.25, y + this.width * 0.1
                );
                
                ctx.strokeStyle = '#6D4C41';
                ctx.lineWidth = 0.7;
                ctx.stroke();
            }
            
            drawSnout(ctx, x, y) {
                // Draw direction-dependent snout
                let snoutX, snoutY, snoutWidth, snoutHeight, angle;
                
                switch(this.direction) {
                    case 'left':
                        snoutX = x - this.width * 0.28;
                        snoutY = y + this.width * 0.12;
                        snoutWidth = this.width * 0.3;
                        snoutHeight = this.width * 0.18;
                        angle = -Math.PI * 0.1; // Angled slightly upward
                        break;
                    case 'right':
                        snoutX = x + this.width * 0.28;
                        snoutY = y + this.width * 0.12;
                        snoutWidth = this.width * 0.3;
                        snoutHeight = this.width * 0.18;
                        angle = Math.PI * 0.1;
                        break;
                    default: // up or down
                        snoutX = x;
                        snoutY = y + this.width * 0.2;
                        snoutWidth = this.width * 0.25;
                        snoutHeight = this.width * 0.22;
                        angle = 0;
                }
                
                // Save context for rotation
                ctx.save();
                ctx.translate(snoutX, snoutY);
                ctx.rotate(angle);
                
                // Draw snout with gradient
                const snoutGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, snoutWidth);
                snoutGradient.addColorStop(0, '#A98274'); // Lighter brown in center
                snoutGradient.addColorStop(1, '#8D6E63'); // Darker at edges
                
                ctx.fillStyle = snoutGradient;
                ctx.beginPath();
                
                if (this.direction === 'left') {
                    // Left-facing pointed snout
                    ctx.ellipse(-snoutWidth * 0.2, 0, snoutWidth, snoutHeight, 0, 0, Math.PI * 2);
                } else if (this.direction === 'right') {
                    // Right-facing pointed snout
                    ctx.ellipse(snoutWidth * 0.2, 0, snoutWidth, snoutHeight, 0, 0, Math.PI * 2);
                } else {
                    // Forward-facing snout
                    ctx.ellipse(0, 0, snoutWidth, snoutHeight, 0, 0, Math.PI * 2);
                }
                
                ctx.fill();
                ctx.strokeStyle = '#6D4C41';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Draw nose
                let noseX, noseY;
                if (this.direction === 'left') {
                    noseX = -snoutWidth;
                    noseY = -snoutHeight * 0.2;
                } else if (this.direction === 'right') {
                    noseX = snoutWidth;
                    noseY = -snoutHeight * 0.2;
                } else {
                    noseX = 0;
                    noseY = snoutHeight * 0.5;
                }
                
                // Draw nose with gradient for wet look
                const noseGradient = ctx.createRadialGradient(
                    noseX, noseY, 0,
                    noseX, noseY, this.width * 0.1
                );
                noseGradient.addColorStop(0, '#1A1A1A'); // Very dark in center
                noseGradient.addColorStop(1, '#000000'); // Black at edges
                
                ctx.beginPath();
                ctx.ellipse(noseX, noseY, this.width * 0.1, this.width * 0.07, 0, 0, Math.PI * 2);
                ctx.fillStyle = noseGradient;
                ctx.fill();
                
                // Add a shine to the nose
                ctx.beginPath();
                ctx.ellipse(
                    noseX - this.width * 0.03, 
                    noseY - this.width * 0.02, 
                    this.width * 0.03, 
                    this.width * 0.02, 
                    Math.PI/4, 0, Math.PI * 2
                );
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fill();
                
                // Draw mouth/muzzle details
                ctx.beginPath();
                
                if (this.direction === 'left') {
                    // Left-facing mouth
                    ctx.moveTo(-snoutWidth * 0.9, 0);
                    ctx.quadraticCurveTo(-snoutWidth * 0.5, snoutHeight * 0.4, 0, 0);
                    
                    // Add jowl line
                    ctx.moveTo(-snoutWidth * 0.7, snoutHeight * 0.3);
                    ctx.quadraticCurveTo(-snoutWidth * 0.4, snoutHeight * 0.6, -snoutWidth * 0.2, snoutHeight * 0.5);
                } else if (this.direction === 'right') {
                    // Right-facing mouth
                    ctx.moveTo(snoutWidth * 0.9, 0);
                    ctx.quadraticCurveTo(snoutWidth * 0.5, snoutHeight * 0.4, 0, 0);
                    
                    // Add jowl line
                    ctx.moveTo(snoutWidth * 0.7, snoutHeight * 0.3);
                    ctx.quadraticCurveTo(snoutWidth * 0.4, snoutHeight * 0.6, snoutWidth * 0.2, snoutHeight * 0.5);
                } else {
                    // Forward-facing mouth - curved smile
                    ctx.moveTo(-snoutWidth * 0.5, snoutHeight * 0.1);
                    ctx.quadraticCurveTo(0, snoutHeight * 0.5, snoutWidth * 0.5, snoutHeight * 0.1);
                    
                    // Add center line
                    ctx.moveTo(0, snoutHeight * 0.5);
                    ctx.lineTo(0, snoutHeight * 0.8);
                }
                
                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = 1.2;
                ctx.stroke();
                
                // Restore context
                ctx.restore();
            }
            
            // Check proximity to blob
            isNearBlob(blob, proximityDistance = 80) {
                const dx = this.x - blob.x;
                const dy = this.y - blob.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < proximityDistance;
            }
            
            // Check if food circle is touching the blob
            isFoodTouchingBlob(blob) {
                if (!this.isFeeding) return false;
                
                const dx = this.foodCircle.x - blob.x;
                const dy = this.foodCircle.y - blob.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Adjust collision detection to work with larger blob sizes
                // Use the actual blob radius plus a fixed margin to ensure consistent feeding
                const blobEffectiveRadius = blob.radius * 1.2;
                
                console.log('Food-blob distance:', distance, 'Blob radius:', blob.radius, 'Effective radius:', blobEffectiveRadius, 'Food radius:', this.foodCircle.radius);
                
                // Use a more generous collision margin to ensure feeding works reliably with the larger blob
                return distance < (this.foodCircle.radius + blobEffectiveRadius + 15);
            }

            // Method to feed the blob
            feedBlob() {
                if (this.inventory.selectedItem && this.inventory.items[this.inventory.selectedItem]) {
                    const selectedItem = this.inventory.items[this.inventory.selectedItem];
                    
                    // Get the target blob from the game
                    const blob = window.gameInstance.blob;
                    
                    // Create a food object from the inventory item
                    if (blob && this.activeFood) {
                        // Save the item name before potentially removing it
                        const itemName = selectedItem.name;
                        
                        // Remove one item from inventory
                        if (this.inventory.removeItem(itemName, 1)) {
                            console.log('Fed blob with:', itemName);
                            // Call the blob's method to consume the food and track evolution
                            const didEvolve = blob.consumePersonFood(this.activeFood);
                            
                            // Force refresh the inventory display regardless of evolution
                            setTimeout(() => {
                                // Trigger inventory update
                                const event = new CustomEvent('inventorySelectionChanged', {
                                    detail: {
                                        selectedItem: this.inventory.selectedItem,
                                        previousSelectedItem: this.inventory.selectedItem
                                    }
                                });
                                window.dispatchEvent(event);
                                console.log('Forced inventory refresh after feeding');
                            }, 50);
                            
                            // If we've run out of the selected item, clear selection and feeding state
                            if (!this.inventory.items[itemName]) {
                                this.inventory.selectedItem = null;
                                this.activeFood = null;
                                this.isFeeding = false;
                                this.showMessage("Out of food!");
                            }
                        } else {
                            console.log('Failed to remove item from inventory');
                            this.showMessage("Out of food!");
                            this.activeFood = null;
                            this.isFeeding = false;
                        }
                    }
                } else if (this.isFeeding) {
                    // Handle case where feeding is active but no valid selection exists
                    this.showMessage("Select food from inventory first!");
                    this.activeFood = null;
                    this.isFeeding = false;
                }
            }

            // Update and draw messages
            updateMessages() {
                if (!this.messages || !Array.isArray(this.messages)) {
                    this.messages = [];
                    return;
                }
                
                const now = Date.now();
                
                for (let i = this.messages.length - 1; i >= 0; i--) {
                    const message = this.messages[i];
                    
                    // Check if message has all required properties
                    if (!message || !message.startTime) {
                        this.messages.splice(i, 1);
                        continue;
                    }
                    
                    const elapsed = now - message.startTime;
                    
                    if (elapsed >= message.duration) {
                        this.messages.splice(i, 1);
                    } else {
                        message.y -= 0.5; // Float upward
                        message.alpha = 1.0 - (elapsed / message.duration);
                    }
                }
            }

            drawMessages(ctx, cameraX, cameraY) {
                // Check if messages array exists
                if (!this.messages || !Array.isArray(this.messages)) {
                    this.messages = [];
                    return;
                }
                
                // First, make sure we don't have more than 5 messages at once to prevent clutter
                if (this.messages.length > 5) {
                    // Keep only the 5 newest messages
                    this.messages = this.messages.slice(-5);
                }
                
                ctx.textAlign = 'center';
                ctx.font = '14px Arial';
                
                // Create a small offset for message positions to prevent overlap
                let messageOffset = 0;
                
                this.messages.forEach((message, index) => {
                    // Calculate screen position for the message
                    const screenX = message.x - cameraX;
                    const screenY = message.y - cameraY - (messageOffset * index);
                    
                    // Draw message with fading effect
                    ctx.fillStyle = `rgba(255, 255, 255, ${message.alpha})`;
                    ctx.strokeStyle = `rgba(0, 0, 0, ${message.alpha})`;
                    ctx.lineWidth = 2;
                    
                    // Draw text stroke for better visibility, using a shadow instead of stroke
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    
                    // Draw main text
                    ctx.fillText(message.text, screenX, screenY);
                    
                    // Reset shadow to prevent it from affecting other drawing operations
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                });
                
                // Reset text alignment
                ctx.textAlign = 'left';
            }
        }

        // Building class
        class Building {
            constructor(x, y, type, size) {
                this.x = x;
                this.y = y;
                this.type = type; // 'house', 'farm', 'tower', etc.
                this.size = size || 1; // Size multiplier
                this.width = 60 * this.size;
                this.height = 50 * this.size;
                this.color = this.getBuildingColor();
                this.level = 1;
                this.health = 100;
                this.completed = false; // Buildings start incomplete
                this.constructionProgress = 0; // 0 to 100
            }
            
            getBuildingColor() {
                switch(this.type) {
                    case 'house': return '#8B4513'; // Brown
                    case 'farm': return '#228B22'; // Green
                    case 'tower': return '#708090'; // Slate gray
                    case 'workshop': return '#B8860B'; // Dark golden
                    default: return '#A0522D'; // Sienna
                }
            }
            
            update() {
                // Buildings can have update logic
                // For example, farms could generate food items over time
            }
            
            draw(ctx, cameraX, cameraY) {
                // Calculate screen position
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Only draw if on screen or near screen
                if (screenX + this.width < -100 || screenX > ctx.canvas.width + 100 || 
                    screenY + this.height < -100 || screenY > ctx.canvas.height + 100) {
                    return;
                }
                
                // Draw foundation
                ctx.fillStyle = '#696969'; // Dim gray for foundation
                ctx.fillRect(screenX, screenY + this.height * 0.8, this.width, this.height * 0.2);
                
                if (this.completed) {
                    this.drawCompletedBuilding(ctx, screenX, screenY);
                } else {
                    this.drawConstructionSite(ctx, screenX, screenY);
                }
            }
            
            drawCompletedBuilding(ctx, x, y) {
                switch(this.type) {
                    case 'house':
                        // Main structure
                        ctx.fillStyle = this.color;
                        ctx.fillRect(x, y, this.width, this.height * 0.8);
                        
                        // Roof
                        ctx.beginPath();
                        ctx.moveTo(x - 10, y);
                        ctx.lineTo(x + this.width + 10, y);
                        ctx.lineTo(x + this.width / 2, y - this.height * 0.4);
                        ctx.closePath();
                        ctx.fillStyle = '#A52A2A'; // Brown roof
                        ctx.fill();
                        
                        // Door
                        ctx.fillStyle = '#8B4513'; // Dark brown
                        ctx.fillRect(x + this.width * 0.4, y + this.height * 0.4, this.width * 0.2, this.height * 0.4);
                        
                        // Windows
                        ctx.fillStyle = '#87CEEB'; // Sky blue
                        ctx.fillRect(x + this.width * 0.15, y + this.height * 0.2, this.width * 0.2, this.height * 0.2);
                        ctx.fillRect(x + this.width * 0.65, y + this.height * 0.2, this.width * 0.2, this.height * 0.2);
                        break;
                        
                    case 'farm':
                        // Field
                        ctx.fillStyle = '#7CFC00'; // Lawn green
                        ctx.fillRect(x, y, this.width, this.height * 0.6);
                        
                        // Crops (rows)
                        ctx.fillStyle = '#006400'; // Dark green
                        for (let i = 0; i < 5; i++) {
                            ctx.fillRect(x + this.width * 0.1, y + this.height * (0.1 + i * 0.1), this.width * 0.8, this.height * 0.05);
                        }
                        
                        // Small shed
                        ctx.fillStyle = '#8B4513'; // Brown
                        ctx.fillRect(x + this.width * 0.7, y + this.height * 0.1, this.width * 0.2, this.height * 0.3);
                        break;
                        
                    case 'tower':
                        // Tower base
                        ctx.fillStyle = this.color;
                        ctx.fillRect(x + this.width * 0.25, y, this.width * 0.5, this.height * 0.8);
                        
                        // Tower top
                        ctx.beginPath();
                        ctx.moveTo(x + this.width * 0.2, y);
                        ctx.lineTo(x + this.width * 0.8, y);
                        ctx.lineTo(x + this.width * 0.6, y - this.height * 0.3);
                        ctx.lineTo(x + this.width * 0.4, y - this.height * 0.3);
                        ctx.closePath();
                        ctx.fillStyle = '#36454F'; // Charcoal
                        ctx.fill();
                        
                        // Windows
                        ctx.fillStyle = '#000000'; // Black
                        ctx.fillRect(x + this.width * 0.4, y + this.height * 0.1, this.width * 0.2, this.height * 0.1);
                        ctx.fillRect(x + this.width * 0.4, y + this.height * 0.3, this.width * 0.2, this.height * 0.1);
                        ctx.fillRect(x + this.width * 0.4, y + this.height * 0.5, this.width * 0.2, this.height * 0.1);
                        break;
                        
                    case 'workshop':
                        // Main structure
                        ctx.fillStyle = this.color;
                        ctx.fillRect(x, y, this.width, this.height * 0.7);
                        
                        // Roof
                        ctx.fillStyle = '#2F4F4F'; // Dark slate gray
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + this.width, y);
                        ctx.lineTo(x + this.width, y - this.height * 0.2);
                        ctx.lineTo(x, y - this.height * 0.2);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Door and chimney
                        ctx.fillStyle = '#8B4513'; // Dark brown
                        ctx.fillRect(x + this.width * 0.4, y + this.height * 0.3, this.width * 0.2, this.height * 0.4);
                        ctx.fillStyle = '#A52A2A'; // Brown
                        ctx.fillRect(x + this.width * 0.8, y - this.height * 0.4, this.width * 0.1, this.height * 0.4);
                        break;
                        
                    default:
                        // Generic building
                        ctx.fillStyle = this.color;
                        ctx.fillRect(x, y, this.width, this.height * 0.8);
                        break;
                }
                
                // Show building type and level
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${this.type} (Level ${this.level})`, x + this.width / 2, y - this.height * 0.1);
            }
            
            drawConstructionSite(ctx, x, y) {
                // Draw scaffolding
                ctx.strokeStyle = '#DAA520'; // Golden rod for scaffolding
                ctx.lineWidth = 2;
                
                // Horizontal scaffold lines
                for (let i = 0; i <= 3; i++) {
                    const yPos = y + (this.height * 0.8 / 3) * i;
                    ctx.beginPath();
                    ctx.moveTo(x, yPos);
                    ctx.lineTo(x + this.width, yPos);
                    ctx.stroke();
                }
                
                // Vertical scaffold lines
                for (let i = 0; i <= 3; i++) {
                    const xPos = x + (this.width / 3) * i;
                    ctx.beginPath();
                    ctx.moveTo(xPos, y);
                    ctx.lineTo(xPos, y + this.height * 0.8);
                    ctx.stroke();
                }
                
                // Draw partial building based on progress
                const progressHeight = (this.height * 0.8) * (this.constructionProgress / 100);
                ctx.fillStyle = this.color;
                ctx.fillRect(x, y + (this.height * 0.8) - progressHeight, this.width, progressHeight);
                
                // Show construction progress
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Building ${this.type}: ${Math.round(this.constructionProgress)}%`, 
                            x + this.width / 2, y - 10);
            }
            
            // Check if coordinates are inside this building
            contains(x, y) {
                return (
                    x >= this.x && x <= this.x + this.width &&
                    y >= this.y && y <= this.y + this.height
                );
            }
            
            // Continue construction of the building
            continueConstruction(amount) {
                this.constructionProgress += amount;
                if (this.constructionProgress >= 100) {
                    this.constructionProgress = 100;
                    this.completed = true;
                    return true; // Construction completed
                }
                return false; // Still under construction
            }
        }

        // Building Manager class to handle multiple buildings
        class BuildingManager {
            constructor() {
                this.buildings = [];
                this.blueprints = {
                    'house': {
                        name: 'House',
                        description: 'A simple shelter',
                        resources: { 'Wood': 10, 'Stone': 5 },
                        size: 1
                    },
                    'farm': {
                        name: 'Farm',
                        description: 'Produces food over time',
                        resources: { 'Wood': 5, 'Berries': 10, 'Nuts': 5 },
                        size: 1.2
                    },
                    'tower': {
                        name: 'Tower',
                        description: 'Keeps watch over a large area',
                        resources: { 'Stone': 15, 'Wood': 5 },
                        size: 0.8
                    },
                    'workshop': {
                        name: 'Workshop',
                        description: 'Crafts new items',
                        resources: { 'Wood': 15, 'Stone': 10, 'Minerals': 5 },
                        size: 1.1
                    }
                };
            }
            
            addBuilding(x, y, type) {
                const blueprint = this.blueprints[type];
                if (!blueprint) return null;
                
                const building = new Building(x, y, type, blueprint.size);
                this.buildings.push(building);
                return building;
            }
            
            update() {
                this.buildings.forEach(building => building.update());
            }
            
            draw(ctx, cameraX, cameraY) {
                this.buildings.forEach(building => building.draw(ctx, cameraX, cameraY));
            }
            
            // Check if there's a building at the given position
            getBuildingAt(x, y) {
                return this.buildings.find(building => building.contains(x, y));
            }
            
            // Check if we can build at this location (not overlapping with other buildings)
            canBuildAt(x, y, type) {
                const blueprint = this.blueprints[type];
                if (!blueprint) return false;
                
                // Create a temporary building to check dimensions
                const tempBuilding = new Building(x, y, type, blueprint.size);
                
                // Check if it overlaps with any existing building
                for (const building of this.buildings) {
                    if (this.checkOverlap(tempBuilding, building)) {
                        return false;
                    }
                }
                
                return true;
            }
            
            // Helper to check if two buildings overlap
            checkOverlap(building1, building2) {
                return !(building1.x + building1.width < building2.x || 
                        building1.x > building2.x + building2.width || 
                        building1.y + building1.height < building2.y || 
                        building1.y > building2.y + building2.height);
            }
            
            // Check if player has enough resources to build
            canAffordBuilding(type, inventory) {
                const blueprint = this.blueprints[type];
                if (!blueprint) return false;
                
                // Check each required resource
                for (const [resource, amount] of Object.entries(blueprint.resources)) {
                    const item = Object.values(inventory.items).find(i => i.name === resource);
                    if (!item || item.quantity < amount) {
                        return false;
                    }
                }
                
                return true;
            }
            
            // Consume resources to build
            consumeResources(type, inventory) {
                const blueprint = this.blueprints[type];
                if (!blueprint) return false;
                
                // Remove each required resource
                for (const [resource, amount] of Object.entries(blueprint.resources)) {
                    const item = Object.values(inventory.items).find(i => i.name === resource);
                    if (item && item.quantity >= amount) {
                        inventory.removeItem(item.name, amount);
                    } else {
                        return false;
                    }
                }
                
                return true;
            }
        }

        // KeyDisplay class to show active keys
        class KeyDisplay {
            constructor() {
                // Set up key tracking with name, pressed state, and cooldown timer
                this.keys = {
                    // Movement keys - Person
                    'KeyW': { name: 'W', pressed: false, timer: 0 },
                    'KeyA': { name: 'A', pressed: false, timer: 0 },
                    'KeyS': { name: 'S', pressed: false, timer: 0 },
                    'KeyD': { name: 'D', pressed: false, timer: 0 },
                    
                    // Movement keys - Blob
                    'ArrowUp': { name: '↑', pressed: false, timer: 0 },
                    'ArrowLeft': { name: '←', pressed: false, timer: 0 },
                    'ArrowDown': { name: '↓', pressed: false, timer: 0 },
                    'ArrowRight': { name: '→', pressed: false, timer: 0 },
                    
                    // Action keys
                    'KeyQ': { name: 'Q', pressed: false, timer: 0 },
                    'KeyG': { name: 'G', pressed: false, timer: 0 },
                    'KeyP': { name: 'P', pressed: false, timer: 0 },
                    'KeyR': { name: 'R', pressed: false, timer: 0 }
                };
                
                // Cooldown time for key display in milliseconds
                this.cooldownTime = 300;
                
                // Last update time for calculating delta time
                this.lastUpdateTime = Date.now();
                
                // Set up event listeners
                this.setupListeners();
            }
            
            setupListeners() {
                // Add event listeners for keydown and keyup
                window.addEventListener('keydown', (e) => {
                    if (this.keys[e.code]) {
                        this.keys[e.code].pressed = true;
                        this.keys[e.code].timer = this.cooldownTime; // Reset timer on key press
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    if (this.keys[e.code]) {
                        this.keys[e.code].pressed = false;
                        // Don't reset timer here, let it count down naturally for visual feedback
                    }
                });
            }
            
            update() {
                const now = Date.now();
                const deltaTime = now - this.lastUpdateTime;
                this.lastUpdateTime = now;
                
                // Update timers for all keys
                for (const key in this.keys) {
                    if (this.keys[key].timer > 0) {
                        this.keys[key].timer = Math.max(0, this.keys[key].timer - deltaTime);
                    }
                }
            }
            
            draw(ctx, canvasWidth, canvasHeight) {
                // Set up dimensions and positioning - reduce panel size to match other OSDs
                const keySize = 24; // Reduced from 32 
                const keyMargin = 6; // Reduced from 8
                const padding = 10;
                const panelWidth = 220; // Reduced from 280
                const panelHeight = 130; // Reduced from 160
                
                // Position in the bottom right corner
                const panelX = canvasWidth - panelWidth - padding;
                const panelY = canvasHeight - panelHeight - padding;
                
                // Draw semi-transparent background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
                
                // Draw panel title
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial'; // Reduced from 14px to match other OSDs
                ctx.textAlign = 'center';
                ctx.fillText('Key Display', panelX + panelWidth / 2, panelY + 16);
                
                // Draw key groups with more horizontal space between them and better margins
                this.drawWASDKeys(ctx, panelX + 50, panelY + 35, keySize, keyMargin); // Adjusted positions
                this.drawArrowKeys(ctx, panelX + 150, panelY + 35, keySize, keyMargin); // Adjusted positions
                
                // Center action keys
                const actionKeysX = panelX + (panelWidth - (keySize * 2 + keyMargin)) / 2;
                this.drawActionKeys(ctx, actionKeysX, panelY + 95, keySize, keyMargin); // Adjusted Y position
                
                // Reset text alignment
                ctx.textAlign = 'left';
            }
            
            drawWASDKeys(ctx, x, y, keySize, margin) {
                // W key (top)
                this.drawKey(ctx, x, y, keySize, 'KeyW');
                
                // A, S, D keys (bottom row)
                this.drawKey(ctx, x - keySize - margin, y + keySize + margin, keySize, 'KeyA');
                this.drawKey(ctx, x, y + keySize + margin, keySize, 'KeyS');
                this.drawKey(ctx, x + keySize + margin, y + keySize + margin, keySize, 'KeyD');
            }
            
            drawArrowKeys(ctx, x, y, keySize, margin) {
                // Up arrow (top)
                this.drawKey(ctx, x, y, keySize, 'ArrowUp');
                
                // Left, Down, Right arrows (bottom row)
                this.drawKey(ctx, x - keySize - margin, y + keySize + margin, keySize, 'ArrowLeft');
                this.drawKey(ctx, x, y + keySize + margin, keySize, 'ArrowDown');
                this.drawKey(ctx, x + keySize + margin, y + keySize + margin, keySize, 'ArrowRight');
            }
            
            drawActionKeys(ctx, x, y, keySize, margin) {
                // Only show Q and P keys
                const actionKeys = ['KeyQ', 'KeyP'];
                let xPos = x;
                
                // Draw action keys in a row
                actionKeys.forEach(keyCode => {
                    this.drawKey(ctx, xPos, y, keySize, keyCode);
                    xPos += keySize + margin;
                });
            }
            
            drawKey(ctx, x, y, size, keyCode) {
                const key = this.keys[keyCode];
                const isActive = key.pressed || key.timer > 0;
                
                // Draw key background
                if (isActive) {
                    // Bright background for active keys
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.strokeStyle = 'rgba(255, 255, 255, 1)';
                } else {
                    // Dark background for inactive keys
                    ctx.fillStyle = 'rgba(50, 50, 50, 0.8)';
                    ctx.strokeStyle = 'rgba(150, 150, 150, 0.8)';
                }
                
                // Draw key rectangle with rounded corners
                ctx.beginPath();
                ctx.roundRect(x, y, size, size, 4);
                ctx.fill();
                ctx.lineWidth = 1; // Reduced from 2 to 1
                ctx.stroke();
                
                // Draw key label with smaller font
                ctx.font = '10px Arial'; // Reduced from 12px to 10px
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                if (isActive) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 1)'; // Dark text for active keys
                } else {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; // Light text for inactive keys
                }
                
                ctx.fillText(key.name, x + size / 2, y + size / 2);
                ctx.textBaseline = 'alphabetic'; // Reset text baseline
            }
        }

        // Game class
        class Game {
            constructor() {
                console.log('Game initializing...');
                try {
                    this.canvas = new Canvas();
                    console.log('Canvas created');
                    
                    // Add keyboard listener for restart (R key)
                    window.addEventListener('keydown', (e) => {
                        if (e.code === 'KeyR' && this.blob && this.blob.isDead) {
                            console.log('R key pressed - attempting restart');
                            this.blob.resetBlob();
                            const overlay = document.getElementById('deathOverlay');
                            if (overlay) overlay.remove();
                        }
                    });

                    this.world = new World(this.canvas.canvas);
                    console.log('World created');
                    
                    // Create blob in the center of the world
                    const worldSize = this.world.biomeManager.getWorldSize();
                    this.blob = new Blob(
                        worldSize.width / 2,
                        worldSize.height / 2,
                        this.world  // Pass world reference to blob
                    );
                    console.log('Blob created with stats:', this.blob.stats);
                    
                    // Create food manager
                    this.foodManager = new FoodManager(worldSize.width, worldSize.height);
                    console.log('Food manager created');
                    
                    // Create building manager instead of cage
                    this.buildingManager = new BuildingManager();
                    console.log('Building manager created');
                    
                    // Create a person
                    this.person = new Person(
                        worldSize.width / 2 - 200,
                        worldSize.height / 2,
                        this.world  // Pass world reference to person
                    );
                    console.log('Person created');
                    
                    // Create key display
                    this.keyDisplay = new KeyDisplay();
                    console.log('Key display created');
                    
                    // Ensure person and blob messages are initialized
                    if (!this.person.messages) this.person.messages = [];
                    if (!this.blob.messages) this.blob.messages = [];
                    
                    // Set up the person's feed function
                    this.person.feedBlob = () => {
                        if (this.person.isNearBlob(this.blob) || this.person.isFoodTouchingBlob(this.blob)) {
                            if (this.person.activeFood && this.person.inventory.selectedItem) {
                                // Check if we have the selected item in inventory
                                const selectedItem = this.person.inventory.items[this.person.inventory.selectedItem];
                                if (!selectedItem || selectedItem.quantity <= 0) {
                                    this.person.showMessage("Out of food!");
                                    return;
                                }

                                console.log('Feeding blob:', this.person.activeFood);
                                
                                // Save the item name before removing it
                                const itemName = selectedItem.name;
                                
                                // Deep clone the person's inventory before feeding to avoid cross-contamination
                                const personInventoryBeforeFeeding = JSON.parse(JSON.stringify(this.person.inventory.items));
                                
                                // Remove one item from inventory
                                if (this.person.inventory.removeItem(itemName, 1)) {
                                    console.log(`Successfully removed 1 ${itemName} from inventory`);
                                    
                                    // Only feed if item was successfully removed
                                    const didEvolve = this.blob.consumePersonFood(this.person.activeFood);
                                    
                                    // If blob is not a pet yet, check if it's tamed after feeding
                                    if (!this.blob.isPet && this.blob.tamingProgress >= 100) {
                                        this.blob.isPet = true;
                                        this.blob.owner = this.person;
                                    }

                                    // Make sure the person's inventory wasn't affected by blob's evolution
                                    const personInventoryAfterFeeding = this.person.inventory.items;
                                    for (const itemName in personInventoryBeforeFeeding) {
                                        // For any item that was not the fed item, ensure its quantity didn't change
                                        if (itemName !== selectedItem.name) {
                                            const beforeQty = personInventoryBeforeFeeding[itemName].quantity;
                                            if (personInventoryAfterFeeding[itemName] && 
                                                personInventoryAfterFeeding[itemName].quantity !== beforeQty) {
                                                // Restore the original quantity
                                                personInventoryAfterFeeding[itemName].quantity = beforeQty;
                                            }
                                        }
                                    }

                                    // Force UI update regardless of evolution status to prevent inventory freeze
                                    // This is crucial to fix the inventory update issue
                                    setTimeout(() => {
                                        console.log('Forcing inventory refresh after feeding');
                                        const event = new CustomEvent('inventorySelectionChanged', {
                                            detail: {
                                                selectedItem: this.person.inventory.selectedItem,
                                                previousSelectedItem: this.person.inventory.selectedItem
                                            }
                                        });
                                        window.dispatchEvent(event);
                                    }, 50);

                                    // If we've run out of the current item, clear feeding state
                                    if (!this.person.inventory.items[itemName] || 
                                        !this.person.inventory.items[this.person.inventory.selectedItem]) {
                                        this.person.activeFood = null;
                                        this.person.isFeeding = false;
                                        this.person.inventory.selectedItem = null;
                                        this.person.showMessage("Out of food!");
                                    }
                                } else {
                                    console.log('Failed to remove item from inventory');
                                    this.person.showMessage("Out of food!");
                                    this.person.activeFood = null;
                                    this.person.isFeeding = false;
                                }
                            } else {
                                this.person.showMessage("No food selected!");
                            }
                        }
                    };
                    
                    // Default to following the person with the camera
                    this.followPerson = true;
                    
                    // Set up building placement and camera toggle
                    window.addEventListener('keydown', (e) => {
                        // Toggle camera follow target with P key
                        if (e.code === 'KeyP') {
                            this.followPerson = !this.followPerson;
                            console.log('Camera following:', this.followPerson ? 'Person' : 'Blob');
                        }
                        
                        // Place building with M key when in build mode
                        if (e.code === 'KeyM' && this.blob.isBuildMode) {
                            this.blob.startBuilding(this.blob.selectedBuildingType, this.buildingManager);
                        }
                        
                        // Allow naming the pet with N key when not in build mode
                        if (e.code === 'KeyN' && this.blob.isPet && !this.blob.isBuildMode && this.person.isNearBlob(this.blob)) {
                            const newName = prompt('Enter a name for your pet blob:', this.blob.petName);
                            if (newName && newName.trim() !== '') {
                                this.blob.petName = newName.trim();
                                console.log('Blob renamed to:', this.blob.petName);
                            }
                        }
                    });
                    
                    this.statsDisplay = new StatsDisplay(this.canvas.canvas);
                    console.log('Stats display created');
                    
                    // Perform initial draw to make sure blob is visible from the start
                    this.draw();
                    console.log('Initial draw completed');
                    
                    // Now start the game loop
                    this.gameLoop();
                    console.log('Game loop started');
                } catch (error) {
                    console.error('Error initializing game:', error);
                }
            }

            update() {
                try {
                    // Update food manager
                    this.foodManager.update(this.world.biomeManager);
                    
                    // Update person
                    this.person.update(
                        this.world.worldWidth,
                        this.world.worldHeight
                    );
                    
                    // Update blob with world dimensions for wrap-around
                    this.blob.update(
                        this.world.worldWidth,
                        this.world.worldHeight,
                        this.world.biomeManager
                    );
                    
                    // Update key display
                    this.keyDisplay.update();
                    
                    // Check for food collisions
                    this.foodManager.checkCollisions(this.blob);
                    
                    // Check if the food circle is touching the blob (continuous feeding)
                    if (this.person.isFeeding) {
                        // More reliably check if food is touching blob, with debug output
                        const isTouching = this.person.isFoodTouchingBlob(this.blob);
                        
                        if (isTouching) {
                            console.log('Food circle is touching blob - feeding');
                            this.person.feedBlob();
                        }
                    }
                    
                    // Periodically refresh inventory display if items are selected
                    // This helps prevent UI from freezing after evolution
                    if (!this.lastInventoryRefresh || Date.now() - this.lastInventoryRefresh > 1000) {
                        // Trigger a refresh regardless of whether there's a selected item
                        const event = new CustomEvent('inventorySelectionChanged', {
                            detail: {
                                selectedItem: this.person.inventory.selectedItem,
                                previousSelectedItem: this.person.inventory.selectedItem
                            }
                        });
                        window.dispatchEvent(event);
                        this.lastInventoryRefresh = Date.now();
                    }
                    
                    // Update camera to follow person or blob based on selection
                    if (this.followPerson) {
                        this.world.updateCamera(this.person, this.canvas.canvas);
                    } else {
                        this.world.updateCamera(this.blob, this.canvas.canvas);
                    }
                    
                    // Update buildings
                    this.buildingManager.update();
                    
                    // Check if blob is near a building to work on it
                    if (!this.blob.isBuildMode) {
                        for (const building of this.buildingManager.buildings) {
                            if (!building.completed) {
                                const dx = building.x + building.width/2 - this.blob.x;
                                const dy = building.y + building.height/2 - this.blob.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance < building.width) {
                                    this.blob.workOnBuilding(building);
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Check if person is collecting food
                    for (let i = 0; i < this.foodManager.foods.length; i++) {
                        const food = this.foodManager.foods[i];
                        if (!food.collected && this.person.isCollectingFood(food)) {
                            // Add to person's inventory
                            if (food.inventoryItem) {
                                // Create a new instance of the inventory item with the SAME NAME as the food type
                                const newItem = new InventoryItem(
                                    food.inventoryItem.type,
                                    food.type, // Use food.type directly instead of food.inventoryItem.name
                                    food.inventoryItem.description,
                                    food.inventoryItem.rarity,
                                    food.inventoryItem.drawIcon
                                );
                                newItem.quantity = 1; // Ensure quantity is set to 1
                                
                                // Use a separate method for person collection to avoid affecting blob inventory
                                const success = this.person.inventory.addItem(newItem);
                                if (success) {
                                    // Mark as collected but don't invoke blob collection behavior
                                    food.collected = true;
                                    console.log('Person collected:', food.type, 'Current inventory:', this.person.inventory.items);
                                    
                                    // Show a message to indicate collection
                                    this.person.showMessage(`Collected ${food.type}`);
                                    
                                    // Important: make sure this doesn't impact blob's inventory
                                    // by forcing a refresh of both inventories with a slight delay
                                    setTimeout(() => {
                                        // Trigger an inventory update event to refresh the UI
                                        const event = new CustomEvent('inventorySelectionChanged', {
                                            detail: {
                                                selectedItem: this.person.inventory.selectedItem,
                                                previousSelectedItem: this.person.inventory.selectedItem
                                            }
                                        });
                                        window.dispatchEvent(event);
                                    }, 50);
                                } else {
                                    console.log('Inventory full!');
                                    this.person.showMessage('Inventory full!');
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error in update:', error);
                }
            }

            draw() {
                try {
                    this.canvas.clear();
                    
                    // Draw world and biomes first
                    this.world.draw(this.canvas.ctx);
                    
                    // Draw buildings instead of cage
                    this.buildingManager.draw(
                        this.canvas.ctx, 
                        this.world.cameraX, 
                        this.world.cameraY
                    );
                    
                    // Draw food items
                    this.foodManager.draw(
                        this.canvas.ctx, 
                        this.world.cameraX, 
                        this.world.cameraY
                    );
                    
                    // Draw person first (behind blob)
                    this.person.draw(
                        this.canvas.ctx,
                        this.world.cameraX,
                        this.world.cameraY
                    );
                    
                    // Draw blob last (on top)
                    this.blob.draw(
                        this.canvas.ctx, 
                        this.world.cameraX, 
                        this.world.cameraY
                    );
                    
                    // Draw UI elements
                    this.statsDisplay.draw(
                        this.canvas.ctx, 
                        this.blob.stats, 
                        this.blob.currentBiome,
                        this.blob.traits
                    );
                    
                    // Draw controls information
                    this.drawControlsInfo();
                    
                    // Draw key display
                    this.keyDisplay.draw(
                        this.canvas.ctx,
                        this.canvas.canvas.width,
                        this.canvas.canvas.height
                    );
                } catch (error) {
                    console.error('Error in draw:', error);
                    console.error('Error details:', error.message);
                }
            }
            
            drawControlsInfo() {
                const ctx = this.canvas.ctx;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                // Adjust controls panel size and position for mobile format
                ctx.fillRect(this.canvas.canvas.width - 170, 10, 160, 130); // Reduced width from 240 to 160
                
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '12px Arial'; // Reduced font size from 14px to 12px
                ctx.textAlign = 'left';
                ctx.fillText('Controls:', this.canvas.canvas.width - 160, 30);
                ctx.fillText('WASD - Move person', this.canvas.canvas.width - 160, 50);
                ctx.fillText('Arrow Keys - Move blob', this.canvas.canvas.width - 160, 70);
                ctx.fillText('Q - Feed blob', this.canvas.canvas.width - 160, 90);
                ctx.fillText('P - Toggle camera', this.canvas.canvas.width - 160, 110);
                
                // Show current camera focus - shortened text
                ctx.fillStyle = '#FFC107'; // Yellow for highlighting
                ctx.fillText(`Following: ${this.followPerson ? 'Person' : 'Blob'}`, 
                            this.canvas.canvas.width - 160, 130);
                
                // Reset text alignment
                ctx.textAlign = 'left';
            }

            gameLoop() {
                try {
                    this.update();
                    this.draw();
                    requestAnimationFrame(() => this.gameLoop());
                } catch (error) {
                    console.error('Error in game loop:', error);
                }
            }
        }

        // Start the game when the window loads
        window.onload = () => {
            try {
                console.log('Window loaded, starting game...');
                window.gameInstance = new Game();
                console.log('Game initialized successfully');
            } catch (error) {
                console.error('Failed to initialize game:', error);
            }
        };

        // Add global restart function
        function restartGame() {
            console.log('Global restart function called');
            if (window.gameInstance && window.gameInstance.blob) {
                console.log('Resetting blob...');
                window.gameInstance.blob.resetBlob();
                return true;
            }
            console.log('No game instance found');
            return false;
        }
    </script>
</body>
</html> 